<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marcin Benke" />
  <meta name="dcterms.date" content="2020-05-19" />
  <title>Advanced Functional Programming</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Advanced Functional Programming</h1>
<p class="subtitle">Parallelism and Concurrency</p>
<p class="author">Marcin Benke</p>
<p class="date">May 19, 2020</p>
</header>
<h1 id="parallelism-and-concurrency">Parallelism and concurrency</h1>
<p>A <em>parallel</em> program is one that uses a multiplicity of computational hardware (e.g. multiple processor cores) in order to perform computation more quickly. Different parts of the computation are delegated to different processors that execute at the same time (in parallel), so that results may be delivered earlier than if the computation had been performed sequentially.</p>
<p>In contrast, <em>concurrency</em> is a program-structuring technique in which there are multiple threads of control. Notionally the threads of control execute “at the same time”; that is, the user sees their effects interleaved. Whether they actually execute at the same time or not is an implementation detail; a concurrent program can execute on a single processor through interleaved execution, or on multiple physical processors.</p>
<p>— Simon Marlow, <em>Parallel and Concurrent Programming in Haskell</em>.</p>
<h1 id="concurrency">Concurrency</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Control.Concurrent</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">-- forkIO :: IO() -&gt; IO ThreadId</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">System.IO</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" title="7">  hSetBuffering stdout <span class="dt">NoBuffering</span></a>
<a class="sourceLine" id="cb1-8" title="8">  forkIO <span class="op">$</span> forever <span class="op">$</span> <span class="fu">putChar</span> <span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb1-9" title="9">  forkIO <span class="op">$</span> forever <span class="op">$</span> <span class="fu">putChar</span> <span class="ch">&#39;B&#39;</span></a>
<a class="sourceLine" id="cb1-10" title="10">  threadDelay <span class="dv">700</span> <span class="co">-- Suspends the current thread for a given number of μs</span></a></code></pre></div>
<pre><code>./fork +RTS -N2
BABABABABABABABABABABABABABABABABABABABABABBBBBBBBBBBB</code></pre>
<h1 id="synchronisation-mvar">Synchronisation: <code>MVar</code></h1>
<p>One element buffer (lock):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">MVar</span> a</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">newMVar  ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">takeMVar ::</span>  <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">putMVar  ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a  <span class="co">--  Atomic read</span></a></code></pre></div>
<p><code>stdout</code> is guarded by an <code>MVar</code>, hence <code>A</code> and <code>B</code> in the previous example come more or less evenly.</p>
<ul>
<li><code>takeMVar</code> is single-wakeup. That is, if there are multiple threads blocked in <code>takeMVar</code>, and the <code>MVar</code> becomes full, only one thread will be woken up. The runtime guarantees that the woken thread completes its <code>takeMVar</code> operation.</li>
<li>When multiple threads are blocked on an <code>MVar</code>, they are woken up in FIFO order.</li>
<li><code>readMVar</code> is multiple-wakeup, so when multiple readers are blocked on an <code>MVar</code>, all of them are woken up at the same time.</li>
</ul>
<h1 id="asynchronous-io">Asynchronous I/O</h1>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> <span class="dt">GetURL</span>             <span class="co">-- getURL :: String -&gt; IO ByteString</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">import</span> <span class="dt">Control.Concurrent</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-5" title="5">  m1 <span class="ot">&lt;-</span> newEmptyMVar</a>
<a class="sourceLine" id="cb4-6" title="6">  forkIO <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-7" title="7">    r <span class="ot">&lt;-</span> getURL <span class="st">&quot;http://hackage.haskell.org/package/base&quot;</span></a>
<a class="sourceLine" id="cb4-8" title="8">    putMVar m1 r</a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10">  m2 <span class="ot">&lt;-</span> newEmptyMVar</a>
<a class="sourceLine" id="cb4-11" title="11">  forkIO <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-12" title="12">    r <span class="ot">&lt;-</span> getURL <span class="st">&quot;http://hackage.haskell.org/package/parallel&quot;</span></a>
<a class="sourceLine" id="cb4-13" title="13">    putMVar m2 r</a>
<a class="sourceLine" id="cb4-14" title="14"></a>
<a class="sourceLine" id="cb4-15" title="15">  r1 <span class="ot">&lt;-</span> takeMVar m1</a>
<a class="sourceLine" id="cb4-16" title="16">  <span class="fu">putStrLn</span> <span class="st">&quot;1 DONE&quot;</span></a>
<a class="sourceLine" id="cb4-17" title="17">  r2 <span class="ot">&lt;-</span> takeMVar m2</a>
<a class="sourceLine" id="cb4-18" title="18">  <span class="fu">putStrLn</span> <span class="st">&quot;2 DONE&quot;</span></a></code></pre></div>
<pre><code>./geturls1 +RTS -N2
START 2
START 1
1 DONE
2 DONE</code></pre>
<h1 id="better">Better</h1>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Async</span> a <span class="ot">=</span> <span class="dt">Async</span> (<span class="dt">MVar</span> a)</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)</a>
<a class="sourceLine" id="cb6-4" title="4">async action <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-5" title="5">   var <span class="ot">&lt;-</span> newEmptyMVar</a>
<a class="sourceLine" id="cb6-6" title="6">   forkIO (action <span class="op">&gt;&gt;=</span> putMVar var)</a>
<a class="sourceLine" id="cb6-7" title="7">   <span class="fu">return</span> (<span class="dt">Async</span> var)</a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="ot">wait ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb6-10" title="10">wait (<span class="dt">Async</span> var) <span class="ot">=</span> readMVar var</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-13" title="13">  m1 <span class="ot">&lt;-</span> async <span class="op">$</span> getURL <span class="st">&quot;http://hackage.haskell.org/package/base&quot;</span></a>
<a class="sourceLine" id="cb6-14" title="14">  m2 <span class="ot">&lt;-</span> async <span class="op">$</span> getURL <span class="st">&quot;http://hackage.haskell.org/package/parallel&quot;</span></a>
<a class="sourceLine" id="cb6-15" title="15">  wait m1</a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="fu">print</span> <span class="st">&quot;1 DONE&quot;</span></a>
<a class="sourceLine" id="cb6-17" title="17">  wait m2</a>
<a class="sourceLine" id="cb6-18" title="18">  <span class="fu">print</span> <span class="st">&quot;2 DONE&quot;</span></a></code></pre></div>
<h1 id="more">More</h1>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">import</span> <span class="dt">TimeIt</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">import</span> <span class="dt">Text.Printf</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">-- ...</span></a>
<a class="sourceLine" id="cb7-5" title="5">sites <span class="ot">=</span> [<span class="st">&quot;http://www.google.com&quot;</span>,</a>
<a class="sourceLine" id="cb7-6" title="6">         <span class="st">&quot;http://www.bing.com&quot;</span>,</a>
<a class="sourceLine" id="cb7-7" title="7">         <span class="st">&quot;http://www.ellatha.com&quot;</span>,</a>
<a class="sourceLine" id="cb7-8" title="8">         <span class="st">&quot;http://hackage.haskell.org/package/parallel&quot;</span>,</a>
<a class="sourceLine" id="cb7-9" title="9">         <span class="st">&quot;http://hackage.haskell.org/package/base&quot;</span></a>
<a class="sourceLine" id="cb7-10" title="10">        ]</a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12">main <span class="ot">=</span> <span class="fu">mapM</span> (async<span class="op">.</span>http) sites <span class="op">&gt;&gt;=</span> <span class="fu">mapM_</span> wait</a>
<a class="sourceLine" id="cb7-13" title="13"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-14" title="14">   http url <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-15" title="15">     (page, time) <span class="ot">&lt;-</span> timeit <span class="op">$</span> getURL url</a>
<a class="sourceLine" id="cb7-16" title="16">     printf <span class="st">&quot;downloaded: %s (%d bytes, %.3fs)\n&quot;</span> url (B.length page) time</a></code></pre></div>
<pre><code>$ ./geturls
downloaded: http://www.google.com (11827 bytes, 0.38s)
downloaded: http://evemaps.dotlan.net/map/Domain (20668 bytes, 0.41s)
downloaded: http://evemaps.dotlan.net/map/Lonetrek (20702 bytes, 0.49s)
downloaded: http://www.bing.com (90526 bytes, 0.85s)
downloaded: http://www.ellatha.com (56521 bytes, 1.42s)</code></pre>
<!-- Why are results in different order than queries? `mapM` is sequential? -->
<h1 id="ioref">IORef</h1>
<p>A mutable variable in the IO monad:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">data</span> <span class="dt">IORef</span> a</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">newIORef ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> a)</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">readIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ot">writeIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="ot">modifyIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">incRef ::</span> <span class="dt">IORef</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-2" title="2">incRef var <span class="ot">=</span> <span class="kw">do</span> { val <span class="ot">&lt;-</span> readIORef var</a>
<a class="sourceLine" id="cb10-3" title="3">                ; threadDelay <span class="dv">1000</span></a>
<a class="sourceLine" id="cb10-4" title="4">                ; writeIORef var (val<span class="op">+</span><span class="dv">1</span>) }</a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-7" title="7">  px <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></a>
<a class="sourceLine" id="cb10-8" title="8">  incRef px</a>
<a class="sourceLine" id="cb10-9" title="9">  incRef px</a>
<a class="sourceLine" id="cb10-10" title="10">  readIORef px <span class="op">&gt;&gt;=</span> <span class="fu">print</span></a></code></pre></div>
<pre><code>$ ./IORef1
2</code></pre>
<h1 id="concurrently">Concurrently?</h1>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">incRef ::</span> <span class="dt">IORef</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-2" title="2">incRef var <span class="ot">=</span> <span class="kw">do</span> { val <span class="ot">&lt;-</span> readIORef var</a>
<a class="sourceLine" id="cb12-3" title="3">                ; threadDelay <span class="dv">1000</span></a>
<a class="sourceLine" id="cb12-4" title="4">                ; writeIORef var (val<span class="op">+</span><span class="dv">1</span>) }</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-7" title="7">  px <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-8" title="8">  forkIO <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb12-9" title="9">  forkIO <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb12-10" title="10">  threadDelay <span class="dv">3000</span></a>
<a class="sourceLine" id="cb12-11" title="11">  readIORef px <span class="op">&gt;&gt;=</span> <span class="fu">print</span></a></code></pre></div>
<pre><code>$ ./IORef2
1</code></pre>
<p>Oops.</p>
<h1 id="locking">Locking</h1>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">locking ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">MVar</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb14-2" title="2">action <span class="ot">`locking`</span> l <span class="ot">=</span> lock l <span class="op">&gt;&gt;</span> (action <span class="op">&lt;*</span> unlock l)</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" title="5">  gil <span class="ot">&lt;-</span> newMVar ()</a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="kw">let</span> atomically a <span class="ot">=</span> a <span class="ot">`locking`</span> gil</a>
<a class="sourceLine" id="cb14-7" title="7">  main2 atomically</a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9">main2 atomically <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-10" title="10">  px <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></a>
<a class="sourceLine" id="cb14-11" title="11">  forkIO <span class="op">$</span> atomically <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb14-12" title="12">  forkIO <span class="op">$</span> atomically <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb14-13" title="13">  threadDelay <span class="dv">3000</span></a>
<a class="sourceLine" id="cb14-14" title="14">  readIORef px <span class="op">&gt;&gt;=</span> <span class="fu">print</span></a></code></pre></div>
<pre><code>$ runghc IORef3.hs
2</code></pre>
<h1 id="but">…but…</h1>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">main2 atomically <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-2" title="2">  px <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></a>
<a class="sourceLine" id="cb16-3" title="3">  forkIO <span class="op">$</span> atomically <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb16-4" title="4">  forkIO <span class="op">$</span> atomicaly  <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb16-5" title="5">  threadDelay <span class="dv">3000</span></a>
<a class="sourceLine" id="cb16-6" title="6">  readIORef px <span class="op">&gt;&gt;=</span> <span class="fu">print</span></a></code></pre></div>
<pre><code>$ runghc IORef4.hs
1</code></pre>
<h1 id="ioref4.hs">IORef4.hs</h1>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">incRef ::</span> <span class="dt">IORef</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-2" title="2">incRef var <span class="ot">=</span> <span class="kw">do</span> { val <span class="ot">&lt;-</span> readIORef var</a>
<a class="sourceLine" id="cb18-3" title="3">                ; threadDelay <span class="dv">1000</span></a>
<a class="sourceLine" id="cb18-4" title="4">                ; writeIORef var (val<span class="op">+</span><span class="dv">1</span>) }</a>
<a class="sourceLine" id="cb18-5" title="5"></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="ot">locking ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">MVar</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb18-7" title="7">action <span class="ot">`locking`</span> l <span class="ot">=</span> lock l <span class="op">&gt;&gt;</span> (action <span class="op">&lt;*</span> unlock l)</a>
<a class="sourceLine" id="cb18-8" title="8"></a>
<a class="sourceLine" id="cb18-9" title="9">atomicaly <span class="ot">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb18-10" title="10"></a>
<a class="sourceLine" id="cb18-11" title="11">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-12" title="12">  gil <span class="ot">&lt;-</span> newMVar ()</a>
<a class="sourceLine" id="cb18-13" title="13">  <span class="kw">let</span> atomically a <span class="ot">=</span> a <span class="ot">`locking`</span> gil</a>
<a class="sourceLine" id="cb18-14" title="14">  main2 atomically</a>
<a class="sourceLine" id="cb18-15" title="15"></a>
<a class="sourceLine" id="cb18-16" title="16">main2 atomically <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-17" title="17">  px <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></a>
<a class="sourceLine" id="cb18-18" title="18">  forkIO <span class="op">$</span> atomically <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb18-19" title="19">  forkIO <span class="op">$</span> atomicaly  <span class="op">$</span> incRef px</a>
<a class="sourceLine" id="cb18-20" title="20">  threadDelay <span class="dv">3000</span></a>
<a class="sourceLine" id="cb18-21" title="21">  readIORef px <span class="op">&gt;&gt;=</span> <span class="fu">print</span></a></code></pre></div>
<h1 id="exercise-unbounded-channels">Exercise: unbounded channels</h1>
<p><code>MVar</code> represent a one-element channel. Use them to implement unbounded channels:</p>
<pre><code>type Stream a = MVar (Item a)
data Item a   = Item a (Stream a)

newChan :: IO (Chan a)
-- |Build and return a new instance of Chan.

writeChan :: Chan a -&gt; a -&gt; IO ()
-- |Write a value to a Chan.

readChan :: Chan a -&gt; IO a
-- |Read the next value from the Chan.</code></pre>
<p>NB this is available as <code>Control.Concurrent.Chan</code> but try to avoid cheating</p>
<h1 id="bank-accounts">Bank accounts</h1>
<pre><code>void transfer( Account from, Account to, Int amount ) {
     from.withdraw( amount );
     to.deposit( amount ); }</code></pre>
<p>in a concurrent program we need to carefully synchronise</p>
<pre><code>from.lock(); to.lock();
from.withdraw( amount );
to.deposit( amount );
from.unlock(); to.unlock(); }</code></pre>
<p>even this is not good (why?), maybe</p>
<pre><code>if from &lt; to
then { from.lock(); to.lock(); }
else { to.lock(); from.lock(); }</code></pre>
<h1 id="problems-with-locking">Problems with locking</h1>
<ul>
<li><p>not enough locks</p></li>
<li><p>wrong locks - the connection between a lock and data it protects is not always clear</p></li>
<li><p>too many locks - deadlock, starvation</p></li>
<li><p>taking locks in a wrong order</p></li>
</ul>
<p>Better solutions?</p>
<h1 id="software-transactional-memory">Software Transactional Memory</h1>
<pre><code>transfer :: Account -&gt; Account -&gt; Int -&gt; IO ()
-- Transfer ’amount’ from account ’from’ to account ’to’
transfer from to amount = atomically $ do
     deposit to amount
     withdraw from amount</code></pre>
<ul>
<li><p>Atomicity: results of <code>atomically</code> are visible to other threads as a whole</p></li>
<li><p>Isolation: during <code>atomically act</code>, no interference from other threads</p></li>
</ul>
<h1 id="gil">GIL?</h1>
<p>Two problems</p>
<ul>
<li><p>one we have seen already: no isolation guarantee</p></li>
<li><p>killing concurrency (I called the global lock <code>gil</code> on purpose)</p></li>
</ul>
<p>The first problem can be solved using types:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">atomically ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a></code></pre></div>
<p>where <code>STM</code> has no direct access to <code>IORef</code>, only to transaction variables:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">data</span> <span class="dt">TVar</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ot">newTVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> (<span class="dt">TVar</span> a)</a>
<a class="sourceLine" id="cb25-3" title="3"><span class="ot">readTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</a>
<a class="sourceLine" id="cb25-4" title="4"><span class="ot">writeTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</a></code></pre></div>
<p><strong>Exercise:</strong> develop this idea; check its throughput</p>
<h1 id="optimistic-concurrency">Optimistic concurrency</h1>
<ul>
<li>An idea from databases: <code>atomically</code> writes a local log</li>
<li><code>writeTVar</code> writes only to the log, not to shared memory.</li>
<li><code>readTVar</code> checks the log first, if not found reads the memory, writing to the log.</li>
<li>eventually we attempt to commit the transaction:
<ul>
<li>read all vars it reads, compare with the log</li>
<li>if no discrepancies, commit - write from log to memory</li>
<li>otherwise rollback and redo later</li>
</ul></li>
</ul>
<p>Note: the RTS must ensure atomicity of commits</p>
<h1 id="launchmissiles">launchMissiles?</h1>
<p>Transactions can have no side effects other than STM</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">atomically <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-2" title="2">    x <span class="ot">&lt;-</span> readTVar xv</a>
<a class="sourceLine" id="cb26-3" title="3">    y <span class="ot">&lt;-</span> readTVar yv</a>
<a class="sourceLine" id="cb26-4" title="4">    when (x<span class="op">&gt;</span>y) launchMissiles</a></code></pre></div>
<p>``optimistically’’ read values of x,y need not be true</p>
<p>better not to launch missiles…</p>
<h1 id="stm">STM</h1>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">import</span> <span class="dt">Control.Concurrent</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="kw">import</span> <span class="dt">Control.Concurrent.STM</span></a>
<a class="sourceLine" id="cb27-3" title="3"></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="ot">incRef ::</span> <span class="dt">TVar</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb27-5" title="5">incRef var <span class="ot">=</span> atomically <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-6" title="6">                val <span class="ot">&lt;-</span> readTVar var</a>
<a class="sourceLine" id="cb27-7" title="7">                <span class="kw">let</span> x <span class="ot">=</span> <span class="fu">fromInteger</span> <span class="op">$</span> delay baseDelay</a>
<a class="sourceLine" id="cb27-8" title="8">                writeTVar var (val<span class="op">+</span><span class="dv">1</span><span class="op">+</span>x)</a>
<a class="sourceLine" id="cb27-9" title="9"></a>
<a class="sourceLine" id="cb27-10" title="10">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-11" title="11">  px <span class="ot">&lt;-</span> newTVarIO <span class="dv">0</span></a>
<a class="sourceLine" id="cb27-12" title="12">  <span class="fu">mapM</span> forkIO <span class="op">$</span> <span class="fu">replicate</span> <span class="dv">20</span> (incRef px)</a>
<a class="sourceLine" id="cb27-13" title="13">  delay (<span class="dv">30</span><span class="op">*</span>baseDelay) <span class="ot">`seq`</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb27-14" title="14">  atomically (readTVar px) <span class="op">&gt;&gt;=</span> <span class="fu">print</span></a></code></pre></div>
<pre><code>./stm1 +RTS -N2
20</code></pre>
<h1 id="delay">Delay</h1>
<pre><code>baseDelay :: Integer
baseDelay = 10^7

delay :: Integer -&gt; Integer
delay 0 = 0
delay n = delay $! n-1
</code></pre>
<p>See also <code>Control.Concurrent.STM.Delay</code></p>
<h1 id="exercise">Exercise</h1>
<p>Implement <code>withdraw</code>, <code>deposit</code> using STM</p>
<h1 id="blocking-retry">Blocking: <code>retry</code></h1>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="ot">retry ::</span> <span class="dt">STM</span> a</a>
<a class="sourceLine" id="cb30-2" title="2"></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="ot">limitedWithdraw ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</a>
<a class="sourceLine" id="cb30-4" title="4">limitedWithdraw acc amount <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb30-5" title="5">   bal <span class="ot">&lt;-</span> readTVar acc</a>
<a class="sourceLine" id="cb30-6" title="6">   <span class="kw">if</span> amount <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> amount <span class="op">&gt;</span> bal</a>
<a class="sourceLine" id="cb30-7" title="7">      <span class="kw">then</span> retry</a>
<a class="sourceLine" id="cb30-8" title="8">      <span class="kw">else</span> writeTVar acc (bal <span class="op">-</span> amount)</a></code></pre></div>
<p>When not enough funds, stop the transaction and retry later.</p>
<p>The system knows which variables are read and can retry when one of them changes (here: <code>amount</code>).</p>
<h1 id="better-check">Better: <code>check</code></h1>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="ot">limitedWithdraw ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</a>
<a class="sourceLine" id="cb31-2" title="2">limitedWithdraw acc amount <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-3" title="3">   bal <span class="ot">&lt;-</span> readTVar acc</a>
<a class="sourceLine" id="cb31-4" title="4">   check <span class="op">$</span> amount <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> amount <span class="op">&gt;</span> bal</a>
<a class="sourceLine" id="cb31-5" title="5">   writeTVar acc (bal <span class="op">-</span> amount)</a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="ot">check ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</a>
<a class="sourceLine" id="cb31-8" title="8">check <span class="dt">True</span> <span class="ot">=</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb31-9" title="9">check <span class="dt">False</span> <span class="ot">=</span> retry</a></code></pre></div>
<p>NB</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="ot">guard           ::</span> (<span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb32-2" title="2">guard <span class="dt">True</span>      <span class="ot">=</span>  <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb32-3" title="3">guard <span class="dt">False</span>     <span class="ot">=</span>  mzero</a></code></pre></div>
<h1 id="other-uses-of-retry---window-manager">Other uses of retry - window manager</h1>
<p>Marlow, p 181</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="ot">renderThread ::</span> <span class="dt">Display</span> <span class="ot">-&gt;</span> <span class="dt">UserFocus</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb33-2" title="2">renderThread disp focus <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb33-3" title="3">  wins <span class="ot">&lt;-</span> atomically <span class="op">$</span> getWindows disp focus    <span class="co">-- &lt;1&gt;</span></a>
<a class="sourceLine" id="cb33-4" title="4">  loop wins                                     <span class="co">-- &lt;2&gt;</span></a>
<a class="sourceLine" id="cb33-5" title="5"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-6" title="6">  loop wins <span class="ot">=</span> <span class="kw">do</span>                                <span class="co">-- &lt;3&gt;</span></a>
<a class="sourceLine" id="cb33-7" title="7">    render wins                                 <span class="co">-- &lt;4&gt;</span></a>
<a class="sourceLine" id="cb33-8" title="8">    next <span class="ot">&lt;-</span> atomically <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb33-9" title="9">               wins&#39; <span class="ot">&lt;-</span> getWindows disp focus   <span class="co">-- &lt;5&gt;</span></a>
<a class="sourceLine" id="cb33-10" title="10">               <span class="kw">if</span> (wins <span class="op">==</span> wins&#39;)               <span class="co">-- &lt;6&gt;</span></a>
<a class="sourceLine" id="cb33-11" title="11">                   <span class="kw">then</span> retry                   <span class="co">-- &lt;7&gt;</span></a>
<a class="sourceLine" id="cb33-12" title="12">                   <span class="kw">else</span> <span class="fu">return</span> wins&#39;            <span class="co">-- &lt;8&gt;</span></a>
<a class="sourceLine" id="cb33-13" title="13">    loop next</a></code></pre></div>
<p>1: read the current set of windows to display</p>
<p>4: call render to display the current state and then enter a transaction to read the next state.</p>
<p>7: If the states are the same, then there is no need to do anything, so we call <code>retry</code></p>
<p>8: If the states are different, then we return the new state, and the loop iterates with the new state</p>
<h1 id="choice">Choice</h1>
<p>Withdraw from account A, when no funds try account B.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">limitedWithdraw2 ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</a>
<a class="sourceLine" id="cb34-2" title="2">limitedWithdraw2 acc1 acc2 amt <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-3" title="3">   limitedWithdraw acc1 amt <span class="ot">`orElse`</span></a>
<a class="sourceLine" id="cb34-4" title="4">   limitedWithdraw acc2 amt</a></code></pre></div>
<p><code>orElse a1 a2</code></p>
<ul>
<li>execute <code>a1</code></li>
<li>if <code>a1</code> blocks (<code>retry</code>), try <code>a2</code>,</li>
<li>if it also blocks, the whole transaction blocks</li>
</ul>
<h1 id="exercise-tchan">Exercise: TChan</h1>
<p>Reimplement unbounded channels you implemented before using STM:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">data</span> <span class="dt">TChan</span> a <span class="ot">=</span> <span class="dt">TChan</span> (<span class="dt">TVar</span> (<span class="dt">TVarList</span> a))</a>
<a class="sourceLine" id="cb35-2" title="2">                     (<span class="dt">TVar</span> (<span class="dt">TVarList</span> a))</a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="kw">type</span> <span class="dt">TVarList</span> a <span class="ot">=</span> <span class="dt">TVar</span> (<span class="dt">TList</span> a)</a>
<a class="sourceLine" id="cb35-5" title="5"><span class="kw">data</span> <span class="dt">TList</span> a <span class="ot">=</span> <span class="dt">TNil</span> <span class="op">|</span> <span class="dt">TCons</span> a (<span class="dt">TVarList</span> a)</a>
<a class="sourceLine" id="cb35-6" title="6"></a>
<a class="sourceLine" id="cb35-7" title="7"><span class="ot">newTChan ::</span> <span class="dt">STM</span> (<span class="dt">TChan</span> a)</a>
<a class="sourceLine" id="cb35-8" title="8"><span class="ot">readTChan ::</span> <span class="dt">TChan</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</a>
<a class="sourceLine" id="cb35-9" title="9"><span class="ot">writeTChan ::</span> <span class="dt">TChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</a></code></pre></div>
<h1 id="dataflow-parallelism-the-par-monad">Dataflow parallelism: the <code>Par</code> monad</h1>
<p>Between <code>Eval</code> and <code>Concurrent</code>: explicit thread creation but preserving determinism.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">newtype</span> <span class="dt">Par</span> a</a>
<a class="sourceLine" id="cb36-2" title="2"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Par</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Par</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Par</span></a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="ot">runPar ::</span> <span class="dt">Par</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb36-7" title="7"><span class="ot">fork ::</span> <span class="dt">Par</span> () <span class="ot">-&gt;</span> <span class="dt">Par</span> ()</a></code></pre></div>
<p><code>fork</code> executes its argument in parallel with the caller, but does not return anything</p>
<p>we need communication</p>
<h1 id="communication-ivar">Communication — IVar</h1>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">data</span> <span class="dt">IVar</span> a</a>
<a class="sourceLine" id="cb37-2" title="2"><span class="ot">new ::</span> <span class="dt">Par</span> (<span class="dt">IVar</span> a)</a>
<a class="sourceLine" id="cb37-3" title="3"><span class="ot">put ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">IVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> ()</a>
<a class="sourceLine" id="cb37-4" title="4"><span class="ot">get ::</span> <span class="dt">IVar</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> a</a></code></pre></div>
<ul>
<li><p><code>new</code> creates a new, empty var</p></li>
<li><p><code>put</code> fills it with a value (allowed only once)</p></li>
<li><p><code>get</code> gets the value, waiting if necessary</p></li>
</ul>
<h1 id="example-fibonacci">Example: Fibonacci</h1>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1">    runPar <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb38-2" title="2">      i <span class="ot">&lt;-</span> new                          <span class="co">-- &lt;1&gt;</span></a>
<a class="sourceLine" id="cb38-3" title="3">      j <span class="ot">&lt;-</span> new                          <span class="co">-- &lt;1&gt;</span></a>
<a class="sourceLine" id="cb38-4" title="4">      fork (put i (fib n))              <span class="co">-- &lt;2&gt;</span></a>
<a class="sourceLine" id="cb38-5" title="5">      fork (put j (fib m))              <span class="co">-- &lt;2&gt;</span></a>
<a class="sourceLine" id="cb38-6" title="6">      a <span class="ot">&lt;-</span> get i                        <span class="co">-- &lt;3&gt;</span></a>
<a class="sourceLine" id="cb38-7" title="7">      b <span class="ot">&lt;-</span> get j                        <span class="co">-- &lt;3&gt;</span></a>
<a class="sourceLine" id="cb38-8" title="8">      <span class="fu">return</span> (a<span class="op">+</span>b)                      <span class="co">-- &lt;4&gt;</span></a></code></pre></div>
<p>1: create two new <code>IVar</code>s to hold the results</p>
<p>2: fork two independent <code>Par</code> computations</p>
<p>3: wait for the results</p>
<pre><code>./parmonad 34 35 +RTS -N2 -s
  Total   time    1.750s  (  1.096s elapsed)
./parmonad 34 35 +RTS -N1 -s
  Total   time    1.745s  (  1.779s elapsed)</code></pre>
<h1 id="caution">Caution</h1>
<p>There is nothing in the types to stop you from returning an <code>IVar</code> from <code>runPar</code> and passing it to another call of <code>runPar</code>.</p>
<p><strong>This is a Very Bad Idea; don’t do it.</strong></p>
<p>The implementation of the <code>Par</code> monad assumes that <code>IVars</code> are created and used within the same <code>runPar</code>, and breaking this assumption could lead to a runtime error, deadlock, or worse.</p>
<p>The library could prevent you from doing this using qualified types in the same way that the <code>ST</code> monad prevents you from returning an <code>STRef</code> from <code>runST</code>. This is planned for a future version.</p>
<h1 id="dataflow-parallelism-the-par-monad-1">Dataflow parallelism: the <code>Par</code> monad</h1>
<p>A program can be represented as a dataflow network (graph) where vertices represent operations, edges - dependencies.</p>
<p><img src="dataflow-network.png" title="Dataflow network" /></p>
<p>in the graph above, <code>j</code> depends on results of <code>g</code> and <code>h</code>, which in turn need the result of <code>f</code> but are independent of each other.</p>
<p>The dependency graph need not be static, can be built dynamically</p>
<h1 id="code">Code</h1>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="ot">network ::</span> <span class="dt">IVar</span> <span class="dt">In</span> <span class="ot">-&gt;</span> <span class="dt">Par</span> <span class="dt">Out</span></a>
<a class="sourceLine" id="cb40-2" title="2">network inp <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb40-3" title="3"> [vf,vg,vh] <span class="ot">&lt;-</span> <span class="fu">sequence</span> [new,new,new]</a>
<a class="sourceLine" id="cb40-4" title="4"></a>
<a class="sourceLine" id="cb40-5" title="5"> fork <span class="op">$</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> get inp</a>
<a class="sourceLine" id="cb40-6" title="6">           put vf (f x)</a>
<a class="sourceLine" id="cb40-7" title="7"></a>
<a class="sourceLine" id="cb40-8" title="8"> fork <span class="op">$</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> get vf</a>
<a class="sourceLine" id="cb40-9" title="9">           put vg (g x)</a>
<a class="sourceLine" id="cb40-10" title="10"></a>
<a class="sourceLine" id="cb40-11" title="11"> fork <span class="op">$</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> get vf</a>
<a class="sourceLine" id="cb40-12" title="12">           put vh (h x)</a>
<a class="sourceLine" id="cb40-13" title="13"></a>
<a class="sourceLine" id="cb40-14" title="14"> x <span class="ot">&lt;-</span> get vg</a>
<a class="sourceLine" id="cb40-15" title="15"> y <span class="ot">&lt;-</span> get vh</a>
<a class="sourceLine" id="cb40-16" title="16"> <span class="fu">return</span> (j x y)</a>
<a class="sourceLine" id="cb40-17" title="17"></a>
<a class="sourceLine" id="cb40-18" title="18">f x <span class="ot">=</span> x<span class="op">+</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb40-19" title="19">g x <span class="ot">=</span> x<span class="op">+</span>x</a>
<a class="sourceLine" id="cb40-20" title="20">h x <span class="ot">=</span> x<span class="op">*</span>x</a>
<a class="sourceLine" id="cb40-21" title="21">j <span class="ot">=</span> (,)</a>
<a class="sourceLine" id="cb40-22" title="22">main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> runNetwork <span class="dv">2</span></a></code></pre></div>
<pre><code>$ ./parnetwork
(6,9)</code></pre>
<h1 id="sudoku-using-par">Sudoku using <code>Par</code></h1>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb42-2" title="2">    [f] <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb42-3" title="3">    grids <span class="ot">&lt;-</span> <span class="fu">fmap</span> <span class="fu">lines</span> <span class="op">$</span> <span class="fu">readFile</span> f</a>
<a class="sourceLine" id="cb42-4" title="4"></a>
<a class="sourceLine" id="cb42-5" title="5">    <span class="kw">let</span> (as,bs) <span class="ot">=</span> <span class="fu">splitAt</span> (<span class="fu">length</span> grids <span class="ot">`div`</span> <span class="dv">2</span>) grids</a>
<a class="sourceLine" id="cb42-6" title="6"></a>
<a class="sourceLine" id="cb42-7" title="7">    <span class="fu">print</span> <span class="op">$</span> <span class="fu">length</span> <span class="op">$</span> <span class="fu">filter</span> isJust <span class="op">$</span> runPar <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb42-8" title="8">       i1 <span class="ot">&lt;-</span> new</a>
<a class="sourceLine" id="cb42-9" title="9">       i2 <span class="ot">&lt;-</span> new</a>
<a class="sourceLine" id="cb42-10" title="10">       fork <span class="op">$</span> put i1 (<span class="fu">map</span> solve as)</a>
<a class="sourceLine" id="cb42-11" title="11">       fork <span class="op">$</span> put i2 (<span class="fu">map</span> solve bs)</a>
<a class="sourceLine" id="cb42-12" title="12">       as&#39; <span class="ot">&lt;-</span> get i1</a>
<a class="sourceLine" id="cb42-13" title="13">       bs&#39; <span class="ot">&lt;-</span> get i2</a>
<a class="sourceLine" id="cb42-14" title="14">       <span class="fu">return</span> (as&#39; <span class="op">++</span> bs&#39;)</a>
<a class="sourceLine" id="cb42-15" title="15"></a>
<a class="sourceLine" id="cb42-16" title="16"><span class="co">-- sudoku-par2 +RTS -s  -N1 -RTS ../Marlow/sudoku17.1000.txt</span></a>
<a class="sourceLine" id="cb42-17" title="17"><span class="co">--  Total   time    1.528s  (  1.555s elapsed)</span></a>
<a class="sourceLine" id="cb42-18" title="18"><span class="co">-- sudoku-par2 +RTS -s  -N2 -RTS ../Marlow/sudoku17.1000.txt</span></a>
<a class="sourceLine" id="cb42-19" title="19"><span class="co">--  Total   time    1.600s  (  0.998s elapsed)</span></a></code></pre></div>
<h1 id="parmap">parMap</h1>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="ot">spawn ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">Par</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> (<span class="dt">IVar</span> a)</a>
<a class="sourceLine" id="cb43-2" title="2">spawn p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-3" title="3">      i <span class="ot">&lt;-</span> new</a>
<a class="sourceLine" id="cb43-4" title="4">      fork (p <span class="op">&gt;&gt;=</span> put i)</a>
<a class="sourceLine" id="cb43-5" title="5">      <span class="fu">return</span> i</a>
<a class="sourceLine" id="cb43-6" title="6"></a>
<a class="sourceLine" id="cb43-7" title="7">parMapM f as <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-8" title="8">    ibs <span class="ot">&lt;-</span> <span class="fu">mapM</span> (spawn <span class="op">.</span> f) as</a>
<a class="sourceLine" id="cb43-9" title="9">    <span class="fu">mapM</span> get ibs</a>
<a class="sourceLine" id="cb43-10" title="10"></a>
<a class="sourceLine" id="cb43-11" title="11"><span class="co">-- Control.Monad.Par.parMap</span></a>
<a class="sourceLine" id="cb43-12" title="12">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-13" title="13">    [f] <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb43-14" title="14">    grids <span class="ot">&lt;-</span> <span class="fu">fmap</span> <span class="fu">lines</span> <span class="op">$</span> <span class="fu">readFile</span> f</a>
<a class="sourceLine" id="cb43-15" title="15">    <span class="fu">print</span> (<span class="fu">length</span> (<span class="fu">filter</span> isJust (runPar <span class="op">$</span> parMap solve grids)))</a>
<a class="sourceLine" id="cb43-16" title="16"></a>
<a class="sourceLine" id="cb43-17" title="17"><span class="co">-- sudoku-par3 +RTS -s  -N1 -RTS ../Marlow/sudoku17.1000.txt</span></a>
<a class="sourceLine" id="cb43-18" title="18"><span class="co">--   Total   time    1.536s  (  1.577s elapsed)</span></a>
<a class="sourceLine" id="cb43-19" title="19"><span class="co">-- sudoku-par3 +RTS -s  -N2 -RTS ../Marlow/sudoku17.1000.txt</span></a>
<a class="sourceLine" id="cb43-20" title="20"><span class="co">--   Total   time    1.603s  (  0.825s elapsed)</span></a></code></pre></div>
<h1 id="exercise-more-nqueens-variants">Exercise: more <code>nqueens</code> variants</h1>
<p>Rewrite <code>nqueens</code> from last week (using <code>Eval</code>) to use <code>Par</code></p>
<p>Ditto with <code>forkIO+MVar</code></p>
<p>Careful with granularity!</p>
<h1 id="the-end">THE END</h1>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
<h1 id="budowanie-abstrakcji-przy-użyciu-mvar-kanały">Budowanie abstrakcji przy użyciu MVar – kanały</h1>
<p><code>MVar</code>: jednoelementowy bufor/semafor:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="ot">newMVar  ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)</a>
<a class="sourceLine" id="cb45-2" title="2"><span class="ot">takeMVar ::</span>  <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb45-3" title="3"><span class="ot">putMVar  ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p><code>Chan</code>: nieograniczony bufor (kanał)</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">data</span> <span class="dt">Chan</span> a</a>
<a class="sourceLine" id="cb46-2" title="2"><span class="ot">newChan   ::</span> <span class="dt">IO</span> ( <span class="dt">Chan</span> a )</a>
<a class="sourceLine" id="cb46-3" title="3"><span class="ot">readChan  ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb46-4" title="4"><span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<h1 id="asynchroniczne-wyjątki">Asynchroniczne wyjątki</h1>
</body>
</html>
