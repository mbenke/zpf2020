<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marcin Benke" />
  <meta name="dcterms.date" content="2020-05-04" />
  <title>Advanced Functional Programming</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Advanced Functional Programming</h1>
<p class="subtitle">Template Haskell</p>
<p class="author">Marcin Benke</p>
<p class="date">May 4, 2020</p>
</header>
<h1 id="metaprogramming---template-haskell">Metaprogramming - Template Haskell</h1>
<p>Code for today is on github:</p>
<ul>
<li>Code/TH/Here - multiline strings with TH (aka here docs)</li>
<li>Code/TH/Projections - building declarations in TH</li>
<li>Code/TH/QQ - quasiquotation</li>
</ul>
<h1 id="problem-multiline-strings">Problem: multiline strings</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">showClass ::</span> [<span class="dt">Method</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>showClass ms <span class="ot">=</span> <span class="st">&quot;\</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="st">\.class  public Instant\n\</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="st">\.super  java/lang/Object\n\</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="st">\\n\</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="st">\;\n\</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="st">\; standard initializer\n\</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="st">\.method public &lt;init&gt;()V\n\</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="st">\   aload_0\n\</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="st">\   invokespecial java/lang/Object/&lt;init&gt;()V\n\</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="st">\   return\n\</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="st">\.end method\n&quot;</span> <span class="op">++</span> <span class="fu">unlines</span> (<span class="fu">map</span> showMethod ms)</span></code></pre></div>
<h1 id="template-haskell">Template Haskell</h1>
<p>Multiline strings in Haskell according to Haskell Wiki:</p>
<pre><code>{-# LANGUAGE QuasiQuotes #-}
module Main where
import Str

longString = [str|This is a multiline string.
It contains embedded newlines. And Unicode:

Ἐν ἀρχῇ ἦν ὁ Λόγος

It ends here: |]

main = putStrLn longString
</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">module</span> <span class="dt">Str</span>(str) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<p>Let’s try to understand how it works…</p>
<h1 id="parsing-haskell-code-at-runtime">Parsing Haskell code at runtime</h1>
<p>Quotations - <code>[q| ... |]</code> are a mechanism for generating ASTs. The quasiquoter <code>q</code> determines how the bracket content is parsed (default is <code>e</code> for Haskell expressions).</p>
<p>This <a href="https://web.archive.org/web/20180501004533/http://www.hyperedsoftware.com:80/blog/entries/first-stab-th.html">tutorial</a> recommends experimenting in GHCi:</p>
<pre><code>$ ghci -XTemplateHaskell
&gt; :m +Language.Haskell.TH
&gt; runQ [| \x -&gt; 1 |]

LamE [VarP x_0] (LitE (IntegerL 1))

&gt; :t it
it :: Exp

&gt; :i Exp
data Exp
  = VarE Name
  | ConE Name
  | LitE Lit
...
    -- Defined in ‘Language.Haskell.TH.Syntax’

&gt; runQ [| \x -&gt; x + 1 |]  &gt;&gt;= putStrLn . pprint
\x_0 -&gt; x_0 GHC.Num.+ 1</code></pre>
<h1 id="q-runq">Q, runQ</h1>
<pre><code>&gt; :t [| \x -&gt; 1 |]
[| \x -&gt; 1 |] :: ExpQ
&gt; :i ExpQ
type ExpQ = Q Exp   -- Defined in ‘Language.Haskell.TH.Lib.Internal’

&gt; :i Q
newtype Q a = ... -- Defined in ‘Language.Haskell.TH.Syntax’
instance Monad Q

&gt; :t runQ
runQ :: Language.Haskell.TH.Syntax.Quasi m =&gt; Q a -&gt; m a

&gt;: i Quasi
class (MonadIO m, MonadFail m) =&gt; Quasi m where ...
instance Quasi Q
instance Quasi IO</code></pre>
<p>Basically <code>runQ</code> can be used to evaluate <code>Q</code> computations both in the <code>Q</code> context (natural habitat) and the <code>IO</code> context (useful for experimentation).</p>
<!--
(curious about `type role Q nominal`? - see e.g. this [question](https://stackoverflow.com/questions/49209788/simplest-examples-demonstrating-the-need-for-nominal-type-role-in-haskell)
-->
<h1 id="splicing-structure-trees-into-a-program">Splicing structure trees into a program</h1>
<pre><code>&gt; runQ [| succ 1 |]
AppE (VarE GHC.Enum.succ) (LitE (IntegerL 1))

&gt; $(return it)
2

&gt; int = LitE . IntegerL
&gt; $(return (int 42))
42

&gt; 1 + $(return (int 41))
42</code></pre>
<p>but:</p>
<pre><code>&gt; $(return (AppE (VarE GHC.Enum.succ) (LitE (IntegerL 1))))

&lt;interactive&gt;: error:
    Couldn&#39;t match expected type ‘Name’ with actual type ‘a0 -&gt; a0’
    Probable cause: ‘succ’ is applied to too few arguments
    In the first argument of ‘VarE’, namely ‘succ’
    In the first argument of ‘AppE’, namely ‘(VarE succ)’
&gt; $(return (AppE (VarE &quot;GHC.Enum.succ&quot;) (LitE (IntegerL 1))))
&lt;interactive&gt;: error:
    • Couldn&#39;t match expected type ‘Name’ with actual type ‘[Char]’
&gt; :t VarE
VarE :: Name -&gt; Exp</code></pre>
<p><code>VarE</code> needs a <code>Name</code></p>
<h1 id="making-a-name-from-string">Making a Name from String</h1>
<p><code>VarE</code> needs a <code>Name</code></p>
<pre><code>&gt; :t VarE
VarE :: Name -&gt; Exp

&gt; :t mkName
mkName :: String -&gt; Name

&gt; $( return (AppE (VarE (mkName &quot;succ&quot;)) (LitE (IntegerL 1))))
2
</code></pre>
<h1 id="names-patterns-declarations">Names, patterns, declarations</h1>
<p>So far, we have been building expressions, but we can build patterns, declarations, etc.:</p>
<pre><code>&gt; runQ [d| p1 (a,b) = a |]
[FunD p1_0 [Clause [TupP [VarP a_1,VarP b_2]] (NormalB (VarE a_1)) []]]</code></pre>
<p><code>FunD</code> etc - see <a href="https://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH.html#g:18">documentation</a>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">data</span> <span class="dt">Clause</span> <span class="ot">=</span> <span class="dt">Clause</span> [<span class="dt">Pat</span>] <span class="dt">Body</span> [<span class="dt">Dec</span>]  <span class="co">-- f pats = b where decs</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">data</span> <span class="dt">Dec</span>                               <span class="co">-- declaration</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="ot">=</span> <span class="dt">FunD</span> <span class="dt">Name</span> [<span class="dt">Clause</span>]        </span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="op">...</span></span></code></pre></div>
<p>Let us now try to build such a definition ourselves.</p>
<p>Note that we need to use two modules, since definitions to be run during compilation have to be imported from a different module — the code to be run needs to be compiled first.</p>
<p>Otherwise you may see an error like</p>
<pre><code>GHC stage restriction:
      ‘build_p1’ is used in a top-level splice, quasi-quote, or annotation,
      and must be imported, not defined locally</code></pre>
<h1 id="build1">Build1</h1>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">{-# START_FILE Build1.hs #-}</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">module</span> <span class="dt">Build1</span> <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co">-- p1 (a,b) = a</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="ot">build_p1 ::</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb12-8"><a href="#cb12-8"></a>build_p1 <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>    [ <span class="dt">FunD</span> p1</span>
<span id="cb12-10"><a href="#cb12-10"></a>             [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a,<span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) []</span>
<span id="cb12-11"><a href="#cb12-11"></a>             ]</span>
<span id="cb12-12"><a href="#cb12-12"></a>    ] <span class="kw">where</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>       p1 <span class="ot">=</span> mkName <span class="st">&quot;p1&quot;</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>       a <span class="ot">=</span> mkName <span class="st">&quot;a&quot;</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>       b <span class="ot">=</span> mkName <span class="st">&quot;b&quot;</span></span>
<span id="cb12-16"><a href="#cb12-16"></a></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="ot">{-# START_FILE Declare1.hs #-}</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb12-20"><a href="#cb12-20"></a><span class="kw">import</span> <span class="dt">Build1</span></span>
<span id="cb12-21"><a href="#cb12-21"></a></span>
<span id="cb12-22"><a href="#cb12-22"></a><span class="op">$</span>(build_p1)</span>
<span id="cb12-23"><a href="#cb12-23"></a></span>
<span id="cb12-24"><a href="#cb12-24"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> p1 (<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<h1 id="printing-the-declarations-we-built">Printing the declarations we built</h1>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">import</span> <span class="dt">Build1</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">$</span>(build_p1)</span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="ot">pprLn ::</span> <span class="dt">Ppr</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb13-6"><a href="#cb13-6"></a>pprLn <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">.</span> pprint</span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">-- pprint :: Ppr a =&gt; a -&gt; String</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>  decs <span class="ot">&lt;-</span> runQ build_p1</span>
<span id="cb13-11"><a href="#cb13-11"></a>  pprLn decs</span>
<span id="cb13-12"><a href="#cb13-12"></a>  <span class="fu">print</span> <span class="op">$</span> p1(<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<pre><code>p1 (a, b) = a
1</code></pre>
<p>Reminder about <code>runQ</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Quasi</span> m <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">instance</span> <span class="dt">Quasi</span> <span class="dt">Q</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="kw">instance</span> <span class="dt">Quasi</span> <span class="dt">IO</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="ot">runQ ::</span> <span class="dt">Quasi</span> m <span class="ot">=&gt;</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<h1 id="fresh-names">Fresh names</h1>
<p>Building and transforming structure trees for a language with bindings is complicated because of possible name conflicts.</p>
<p>Luckily, TH provides the function <a href="https://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#v:newName">newName</a>:</p>
<pre><code>newName :: String -&gt; Q Name

&gt; runQ ((,) &lt;$&gt; newName &quot;x&quot; &lt;*&gt; newName &quot;x&quot; )
(x_1,x_2)</code></pre>
<p>(which, by the way, explains one of the reasons why <a href="https://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#t:Q">Q</a> needs to be a monad).</p>
<p>Using <code>newName</code> we can safeguard our code against name clashes.</p>
<p>Note, however, that <code>p1</code> is global and must use <code>mkName</code>, while <code>a</code> and <code>b</code> are locals, so we shall generate them using <code>newName</code>.</p>
<h1 id="build2">Build2</h1>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">{-# START_FILE Build2.hs #-}</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">module</span> <span class="dt">Build2</span> <span class="kw">where</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="ot">build_p1 ::</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb17-7"><a href="#cb17-7"></a>build_p1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>  <span class="kw">let</span> p1 <span class="ot">=</span> mkName <span class="st">&quot;p1&quot;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>  a <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>  b <span class="ot">&lt;-</span> newName <span class="st">&quot;b&quot;</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>  <span class="fu">return</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    [ <span class="dt">FunD</span> p1</span>
<span id="cb17-13"><a href="#cb17-13"></a>             [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a,<span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) []</span>
<span id="cb17-14"><a href="#cb17-14"></a>             ]</span>
<span id="cb17-15"><a href="#cb17-15"></a>    ]</span>
<span id="cb17-16"><a href="#cb17-16"></a></span>
<span id="cb17-17"><a href="#cb17-17"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb17-18"><a href="#cb17-18"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb17-19"><a href="#cb17-19"></a><span class="kw">import</span> <span class="dt">Build2</span></span>
<span id="cb17-20"><a href="#cb17-20"></a></span>
<span id="cb17-21"><a href="#cb17-21"></a><span class="op">$</span>(build_p1)</span>
<span id="cb17-22"><a href="#cb17-22"></a></span>
<span id="cb17-23"><a href="#cb17-23"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> p1 (<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<h1 id="typical-th-use">Typical TH use</h1>
<p>Let us define all projections for large (say 16-) tuples. Writing this by hand is no fun, but TH helps avoid the boilerplate.</p>
<p>Here we start by pairs, but extending it to larger tuples is a simple exercise.</p>
<p>An auxiliary function building a simple declaration may come handy, e.g.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>simpleFun name pats rhs <span class="ot">=</span> <span class="dt">FunD</span> name [<span class="dt">Clause</span> pats (<span class="dt">NormalB</span> rhs) []]</span></code></pre></div>
<p>Given a function such that <code>build_p n</code> builds the nth projection, we can build them all using <code>mapM</code></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>build_ps <span class="ot">=</span> <span class="fu">mapM</span> build_p [<span class="dv">1</span>,<span class="dv">2</span>]</span></code></pre></div>
<p>Then we may splice the definitions into the program</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="op">$</span>(build_ps)</span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>  [ p2_1 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb20-5"><a href="#cb20-5"></a>  , p2_2 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb20-6"><a href="#cb20-6"></a>  ]</span></code></pre></div>
<h1 id="build3">Build3</h1>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">{-# START_FILE Build3.hs #-}</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="kw">module</span> <span class="dt">Build3</span> <span class="kw">where</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="ot">simpleFun ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> [<span class="dt">Pat</span>] <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Dec</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>simpleFun name pats rhs <span class="ot">=</span> <span class="dt">FunD</span> name [<span class="dt">Clause</span> pats (<span class="dt">NormalB</span> rhs) []]</span>
<span id="cb21-7"><a href="#cb21-7"></a></span>
<span id="cb21-8"><a href="#cb21-8"></a>build_ps <span class="ot">=</span> <span class="fu">mapM</span> build_p [<span class="dv">1</span>,<span class="dv">2</span>] <span class="kw">where</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>    fname n <span class="ot">=</span> mkName <span class="op">$</span> <span class="st">&quot;p2_&quot;</span> <span class="op">++</span> <span class="fu">show</span> n</span>
<span id="cb21-10"><a href="#cb21-10"></a>    build_p n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>        argNames <span class="ot">&lt;-</span> <span class="fu">mapM</span> newName (<span class="fu">replicate</span> <span class="dv">2</span> <span class="st">&quot;a&quot;</span>)</span>
<span id="cb21-12"><a href="#cb21-12"></a>        <span class="kw">let</span> args <span class="ot">=</span> <span class="fu">map</span> <span class="dt">VarP</span> argNames</span>
<span id="cb21-13"><a href="#cb21-13"></a>        <span class="fu">return</span> <span class="op">$</span> simpleFun (fname n) [<span class="dt">TupP</span> args] (<span class="dt">VarE</span> (argNames <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)))</span>
<span id="cb21-14"><a href="#cb21-14"></a></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="ot">{-# START_FILE Declare3.hs #-}</span></span>
<span id="cb21-16"><a href="#cb21-16"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb21-17"><a href="#cb21-17"></a></span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="kw">import</span> <span class="dt">Build3</span></span>
<span id="cb21-19"><a href="#cb21-19"></a>build_ps <span class="co">-- one may omit $(...) for declarations</span></span>
<span id="cb21-20"><a href="#cb21-20"></a></span>
<span id="cb21-21"><a href="#cb21-21"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span></span>
<span id="cb21-22"><a href="#cb21-22"></a>    [ p2_1 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb21-23"><a href="#cb21-23"></a>    , p2_2 (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb21-24"><a href="#cb21-24"></a>    ]</span></code></pre></div>
<pre><code>1
2</code></pre>
<h1 id="quote-eval-quasiquote">Quote, eval, quasiquote</h1>
<p>In Lisp we have quote: <code>'</code> (<code>code -&gt; data</code>)</p>
<pre><code>(+ 1 1)         =&gt; 2
&#39;(+ 1 1)        =&gt; (list &#39;+ 1 1)
(eval &#39;(+ 1 1)) =&gt; 2
(1 2 3)         ERROR
&#39;(1 2 3)        =&gt; (list 1 2 3)
&#39;(1 (+ 1 1) 3)  =&gt; (list 1 &#39;(+ 1 1) 3)</code></pre>
<p>and a slightly more involved quasiquote/unquote pair: <code>`/,</code> (backtick/comma)</p>
<pre><code>`(1 ,(+ 1 1) 3) =&gt; (list 1 2 3)</code></pre>
<p>enabling us to evaluate some fragments inside quoted code.</p>
<p>In Lisp there are only S-expressions, Haskell syntax is more complex:</p>
<ul>
<li>expressions</li>
<li>patterns</li>
<li>types</li>
<li>declarations</li>
</ul>
<h1 id="quasiquoting">Quasiquoting</h1>
<p>We have seen the standard quasiquoters e, t, d, p (e.g. <code>[e| \x -&gt; x +1|]</code> ). We can also define our own:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a>longString <span class="ot">=</span> [str|This is a multiline string.</span>
<span id="cb25-2"><a href="#cb25-2"></a>It contains embedded newlines. And Unicode:</span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a>Ἐν ἀρχῇ ἦν ὁ Λόγος</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>It ends here: |]</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> longString</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">module</span> <span class="dt">Str</span>(str) <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<ul>
<li><code>stringE</code> builds a string literal expression</li>
<li><code>str</code> quasiquoter, when used in expression context, splices this literal</li>
</ul>
<h1 id="the-quasiquoter-type">The QuasiQuoter type</h1>
<pre><code>&gt; :i QuasiQuoter
data QuasiQuoter
  = QuasiQuoter {quoteExp :: String -&gt; Q Exp,
                 quotePat :: String -&gt; Q Pat,
                 quoteType :: String -&gt; Q Type,
                 quoteDec :: String -&gt; Q [Dec]}
    -- Defined in ‘Language.Haskell.TH.Quote’</code></pre>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a>str <span class="ot">=</span> <span class="dt">QuasiQuoter</span> { quoteExp <span class="ot">=</span> stringE }</span></code></pre></div>
<p>We intend to use <code>str</code> only in expression contexts, so we leave the other parts undefined.</p>
<h1 id="parsing-expressions">Parsing Expressions</h1>
<p>Let’s start with a simple data type and parser for arithmetic expressions</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="dt">Int</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>  <span class="op">|</span> <span class="dt">EAdd</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>  <span class="op">|</span> <span class="dt">ESub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>  <span class="op">|</span> <span class="dt">EMul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>  <span class="op">|</span> <span class="dt">EDiv</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>    <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="co">-- deriving Data needed to use generic function</span></span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="co">-- liftData :: Data a =&gt; a -&gt; ExpQ</span></span>
<span id="cb29-11"><a href="#cb29-11"></a></span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="co">-- ...</span></span>
<span id="cb29-14"><a href="#cb29-14"></a></span>
<span id="cb29-15"><a href="#cb29-15"></a>test1 <span class="ot">=</span> parse pExpr <span class="st">&quot;test1&quot;</span> <span class="st">&quot;1 - 2 - 3 * 4 &quot;</span></span>
<span id="cb29-16"><a href="#cb29-16"></a>main <span class="ot">=</span> <span class="fu">print</span> test1</span></code></pre></div>
<pre><code>Right (ESub (ESub (EInt 1) (EInt 2)) (EMul (EInt 3) (EInt 4)))</code></pre>
<h1 id="building-test-cases">Building test cases</h1>
<p>Now let’s say we need some expresion trees in our program. For this kind of expressions we could (almost) get by with <code>class Num</code> hack:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="dt">EInt</span> <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>  (<span class="op">+</span>) <span class="ot">=</span> <span class="dt">EAdd</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>  (<span class="op">*</span>) <span class="ot">=</span> <span class="dt">EMul</span></span>
<span id="cb31-5"><a href="#cb31-5"></a>  (<span class="op">-</span>) <span class="ot">=</span> <span class="dt">ESub</span></span>
<span id="cb31-6"><a href="#cb31-6"></a></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>testExpr <span class="ot">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span>) <span class="op">*</span> <span class="dv">3</span></span></code></pre></div>
<p>…but it is neither extensible nor, in fact, nice.</p>
<h1 id="building-test-cases-via-parsing">Building test cases via parsing</h1>
<p>Of course as soon as we have a parser ready we could use it to build expressions</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a>testExpr <span class="ot">=</span> parse pExpr <span class="st">&quot;testExpr&quot;</span> <span class="st">&quot;1+2*3&quot;</span></span></code></pre></div>
<p>…but then potential errors in the expression texts remain undetected until runtime, and also this is not flexible enough: what if we wanted a simplifier for expressions, along the lines of</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>simpl (<span class="dt">EAdd</span> (<span class="dt">EInt</span> <span class="dv">0</span>) x) <span class="ot">=</span> x</span></code></pre></div>
<h1 id="why-its-good-to-be-quasiquoted">Why it’s good to be Quasiquoted</h1>
<p>what if we could instead write</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>simpl (<span class="dv">0</span> <span class="op">+</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p>turns out with quasiquotation we can do just that (albeit with a slightly different syntax), so to whet your appetite:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="ot">simpl ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>simpl [expr|0 + $x|] <span class="ot">=</span> x</span>
<span id="cb35-3"><a href="#cb35-3"></a></span>
<span id="cb35-4"><a href="#cb35-4"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> simpl [expr|0+2|]</span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="co">-- ...</span></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="ot">expr  ::</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>expr  <span class="ot">=</span>  <span class="dt">QuasiQuoter</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>  { quoteExp <span class="ot">=</span> quoteExprExp</span>
<span id="cb35-9"><a href="#cb35-9"></a>  , quotePat <span class="ot">=</span> quoteExprPat</span>
<span id="cb35-10"><a href="#cb35-10"></a>  }</span></code></pre></div>
<p>Let us start with the (perhaps simplest) quasiquoter for expressions:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="ot">quoteExprExp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb36-2"><a href="#cb36-2"></a>quoteExprExp s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb36-4"><a href="#cb36-4"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExp pos s</span>
<span id="cb36-5"><a href="#cb36-5"></a>  exprToExpQ <span class="fu">exp</span></span></code></pre></div>
<h1 id="quasiquoting-expressions">Quasiquoting Expressions</h1>
<p>There are three steps:</p>
<ul>
<li>record the current position in Haskell file (for parse error reporting);</li>
<li>parse the expression into our abstract syntax;</li>
<li>convert our abstract syntax to its Template Haskell representation.</li>
</ul>
<p>The first step is accomplished using <a href="http://hackage.haskell.org/packages/archive/template-haskell/2.14.0.0/doc/html/Language-Haskell-TH.html#v:location">Language.Haskell.TH.location</a> and converting it to something usable by Parsec:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>getPosition <span class="ot">=</span> <span class="fu">fmap</span> transPos location <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>  transPos loc <span class="ot">=</span> (loc_filename loc,</span>
<span id="cb37-3"><a href="#cb37-3"></a>                  <span class="fu">fst</span> (loc_start loc),</span>
<span id="cb37-4"><a href="#cb37-4"></a>                  <span class="fu">snd</span> (loc_start loc))</span></code></pre></div>
<p>Parsing is done with our expression parser, but building the Haskell AST is a bit of work.</p>
<h1 id="building-ast">Building AST</h1>
<p>Next we need to build Haskell AST from expression tree built by our parser:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="ot">exprToExpQ ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>exprToExpQ (<span class="dt">EInt</span> n) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">ConE</span> (mkName <span class="st">&quot;EInt&quot;</span>) <span class="op">$$</span> (intLitE n)</span>
<span id="cb38-3"><a href="#cb38-3"></a>exprToExpQ (<span class="dt">EAdd</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EAdd&quot;</span> e1 e2</span>
<span id="cb38-4"><a href="#cb38-4"></a>exprToExpQ (<span class="dt">ESub</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;ESub&quot;</span> e1 e2</span>
<span id="cb38-5"><a href="#cb38-5"></a>exprToExpQ (<span class="dt">EMul</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EMul&quot;</span> e1 e2</span>
<span id="cb38-6"><a href="#cb38-6"></a>exprToExpQ (<span class="dt">EDiv</span> e1 e2) <span class="ot">=</span> convertBinE <span class="st">&quot;EDiv&quot;</span> e1 e2</span>
<span id="cb38-7"><a href="#cb38-7"></a></span>
<span id="cb38-8"><a href="#cb38-8"></a>convertBinE s e1 e2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb38-9"><a href="#cb38-9"></a>  e1&#39; <span class="ot">&lt;-</span> exprToExpQ e1</span>
<span id="cb38-10"><a href="#cb38-10"></a>  e2&#39; <span class="ot">&lt;-</span> exprToExpQ e2  </span>
<span id="cb38-11"><a href="#cb38-11"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">ConE</span> (mkName s) <span class="op">$$</span> e1&#39; <span class="op">$$</span> e2&#39;</span></code></pre></div>
<p>(alternatively we might make our parser return Haskell AST)</p>
<h1 id="scrap-your-boilerplate">Scrap Your Boilerplate</h1>
<p>This seems like a lot of boilerplate, luckily we can save us some work use facilities for generic programming provided by <a href="http://hackage.haskell.org/package/base/docs/Data-Data.html">Data.Data</a> combined with the Template Haskell function <a href="http://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Syntax.html#v:dataToExpQ">dataToExpQ</a>,</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a> exprToExpQ <span class="ot">=</span>  dataToExpQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="co">-- dataToExpQ :: Data a</span></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="co">--            =&gt; (forall b. Data b =&gt; b -&gt; Maybe (Q Exp))</span></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="co">--            -&gt; a -&gt; Q Exp</span></span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="co">-- the first argument provides a way of extending the translation</span></span></code></pre></div>
<p>or a simpler <a href="http://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Syntax.html#v:liftData">liftData</a></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="ot">liftData ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span></code></pre></div>
<h1 id="quasiquoting-patterns">Quasiquoting patterns</h1>
<p>So far, we are halfway through to our goal: we can use the quasiquoter on the right hand side of function definitions:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb41-2"><a href="#cb41-2"></a>testExpr <span class="ot">=</span> [expr|1+2*3|]</span></code></pre></div>
<p>To be able to write things like</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a>simpl [expr|0 + $x|] <span class="ot">=</span> x</span></code></pre></div>
<p>we need to write a quasiquoter for patterns.</p>
<h1 id="quasiquoting-constant-patterns">Quasiquoting constant patterns</h1>
<p>Let us start with something less ambitious - a quasiquoter for constant patterns, allowing us to write</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="ot">testExpr ::</span> <span class="dt">Expr</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>testExpr <span class="ot">=</span> [expr|1+2*3|]</span>
<span id="cb43-3"><a href="#cb43-3"></a></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="ot">f1 ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>f1 [expr| 1 + 2*3 |] <span class="ot">=</span> <span class="st">&quot;Bingo!&quot;</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>f1 _ <span class="ot">=</span> <span class="st">&quot;Sorry, no bonus&quot;</span></span>
<span id="cb43-7"><a href="#cb43-7"></a></span>
<span id="cb43-8"><a href="#cb43-8"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> f1 testExpr</span></code></pre></div>
<p>This can be done similarly to the quasiquoter for expressions:</p>
<ul>
<li>record the current position in Haskell file (for parse error reporting);</li>
<li>parse the expression into our abstract syntax;</li>
<li>convert our abstract syntax to its Template Haskell representation.</li>
</ul>
<h1 id="building-pattern-ast">Building pattern AST</h1>
<p>This time we need to construct Template Haskell pattern representation:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">TH.Q</span> <span class="dt">TH.Pat</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-3"><a href="#cb44-3"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb44-4"><a href="#cb44-4"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExpr pos s</span>
<span id="cb44-5"><a href="#cb44-5"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span></code></pre></div>
<p>The functions <code>quoteExprExp</code> and <code>quoteExprPat</code> differ in two respects:</p>
<ul>
<li>use <code>dataToPatQ</code> instead of <code>dataToExpQ</code></li>
<li>the result type is different (obviously)</li>
</ul>
<h1 id="antiquotation">Antiquotation</h1>
<p>The quasiquotation mechanism we have seen so far allows us to translate domain-specific code into Haskell and “inject” it into our program.</p>
<p>Antiquotation, as the name suggests goes in the opposite direction: embeds Haskell entities (e.g. variables) in our DSL.</p>
<p>This sounds complicated, but isn’t really. Think HTML templates:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">&lt;html&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="kw">&lt;head&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="kw">&lt;title&gt;</span>#{pageTitle}</span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="kw">&lt;body&gt;&lt;h1&gt;</span>#{pageTitle}</span></code></pre></div>
<p>The meaning is hopefully obvious — the value of program variable <code>pageTitle</code> should be embedded in the indicated places. In our expression language we might want to write</p>
<pre><code>twice :: Expr -&gt; Expr
twice e = [expr| $e + $e |]

testTwice = twice [expr| 3 * 3|]</code></pre>
<p>This is nothing revolutionary. Haskell however, uses variables not only in expressions, but also in patterns, and here the story becomes a little interesting.</p>
<h1 id="extending-quasiquoters">Extending quasiquoters</h1>
<p>Recall the pattern quasiquoter:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb47-4"><a href="#cb47-4"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> parseExpr pos s</span>
<span id="cb47-5"><a href="#cb47-5"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span>) <span class="fu">exp</span></span></code></pre></div>
<p>The <code>(const Nothing)</code> is a placeholder for extensions to the standard <code>Data</code> to <code>Pat</code> translation:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="ot">quoteExprPat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>quoteExprPat s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb48-3"><a href="#cb48-3"></a>  pos <span class="ot">&lt;-</span> getPosition</span>
<span id="cb48-4"><a href="#cb48-4"></a>  <span class="fu">exp</span> <span class="ot">&lt;-</span> Expr.parseExpr pos s</span>
<span id="cb48-5"><a href="#cb48-5"></a>  dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span> <span class="ot">`extQ`</span> antiExprPat) <span class="fu">exp</span></span></code></pre></div>
<p>What are the “extensions”?</p>
<h1 id="whats-a-function-extension">What’s a function extension?</h1>
<p>You have</p>
<ul>
<li>a generic function, say</li>
</ul>
<pre><code>gen :: Data a =&gt; a -&gt; R</code></pre>
<ul>
<li>a type-specific function, say</li>
</ul>
<pre><code>spec :: T -&gt; R</code></pre>
<p>You want a generic function which behaves like spec on values of type T, and like gen on all other values.</p>
<p>The function <code>extQ</code> does just that.</p>
<pre><code>extQ :: (Typeable a, Typeable b) =&gt; (a -&gt; r) -&gt; (t -&gt; r) -&gt; a -&gt; r

gen `extQ` spec :: Data a =&gt; a -&gt; R  -- Data is a subclass of Typeable</code></pre>
<p>(NB <code>extQ</code> comes from <code>Data.Generics</code> and the <code>Q</code> in the name has nothing to do with Template Haskell <code>Q</code> monad)</p>
<h1 id="extending-datatopatq">Extending <code>dataToPatQ</code></h1>
<pre><code>const Nothing :: b -&gt; Maybe (Q Pat)

extQ :: (Data a, Data t) =&gt; (a -&gt; r) -&gt; (t -&gt; r) -&gt; a -&gt; r
-- specialized to Data

antiExprPat :: Expr -&gt; Maybe (Q Pat)

const Nothing `extQ` antiExprPat :: forall b.Data b =&gt; b -&gt; Maybe (Q Pat)

dataToPatQ
  :: Data a =&gt;
     (forall b.Data b =&gt; b -&gt; Maybe (Q Pat)) -&gt; a -&gt; Q Pat
-- specialized To Expr
-- :: (forall b.Data b =&gt; b -&gt; Maybe (Q Pat)) -&gt; Expr -&gt; Q Pat

dataToPatQ (const Nothing `extQ` antiExprPat) :: Expr -&gt; Q Pat</code></pre>
<h1 id="metavariables">Metavariables</h1>
<p>Let us extend our expression syntax and parser with metavariables (variables from the metalanguage):</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span>  <span class="op">...</span> <span class="op">|</span> <span class="dt">EMetaVar</span> <span class="dt">String</span></span>
<span id="cb53-2"><a href="#cb53-2"></a>           <span class="kw">deriving</span>(<span class="dt">Show</span>,<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span>
<span id="cb53-3"><a href="#cb53-3"></a></span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb53-5"><a href="#cb53-5"></a>pExpr <span class="ot">=</span> pTerm <span class="ot">`chainl1`</span> spaced addop</span>
<span id="cb53-6"><a href="#cb53-6"></a></span>
<span id="cb53-7"><a href="#cb53-7"></a>pTerm <span class="ot">=</span> spaced pFactor <span class="ot">`chainl1`</span> spaced mulop</span>
<span id="cb53-8"><a href="#cb53-8"></a>pFactor <span class="ot">=</span> pNum <span class="op">&lt;|&gt;</span> pMetaVar</span>
<span id="cb53-9"><a href="#cb53-9"></a></span>
<span id="cb53-10"><a href="#cb53-10"></a>pMetaVar <span class="ot">=</span> char <span class="ch">&#39;$&#39;</span> <span class="op">&gt;&gt;</span> <span class="dt">EMetaVar</span> <span class="op">&lt;$&gt;</span> ident</span>
<span id="cb53-11"><a href="#cb53-11"></a></span>
<span id="cb53-12"><a href="#cb53-12"></a>test1 <span class="ot">=</span> parse pExpr <span class="st">&quot;test1&quot;</span> <span class="st">&quot;1 - 2 - 3 * 4 &quot;</span></span>
<span id="cb53-13"><a href="#cb53-13"></a>test2 <span class="ot">=</span> parse pExpr <span class="st">&quot;test2&quot;</span> <span class="st">&quot;$x - $y*$z&quot;</span></span></code></pre></div>
<h1 id="antiquoting-metavariables">Antiquoting metavariables</h1>
<p>The antiquoter is defined as an extension for the <code>dataToPatQ</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a><span class="ot">antiExprPat ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Pat</span>)</span>
<span id="cb54-2"><a href="#cb54-2"></a>antiExprPat (<span class="dt">EMetaVar</span> v) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> varP (mkName v)</span>
<span id="cb54-3"><a href="#cb54-3"></a>antiExprPat _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<ul>
<li>metavariables are translated to <code>Just</code> TH variables</li>
<li>for all the other cases we say <code>Nothing</code> - allowing <code>dataToPatQ</code> use its default rules</li>
</ul>
<p>And that’s it! Now we can write</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a>eval [expr| $a + $b|] <span class="ot">=</span> eval a <span class="op">+</span> eval b</span>
<span id="cb55-2"><a href="#cb55-2"></a>eval [expr| $a * $b|] <span class="ot">=</span> eval a <span class="op">*</span> eval b</span>
<span id="cb55-3"><a href="#cb55-3"></a>eval (<span class="dt">EInt</span> n) <span class="ot">=</span> n</span></code></pre></div>
<h1 id="exercises">Exercises</h1>
<ul>
<li>Write a function such that build_ps n generates all projections for n-tuples,</li>
<li>Write a function <code>tupleFromList</code> such that</li>
</ul>
<pre><code>$(tupleFromList 8) [1..8] == (1,2,3,4,5,6,7,8)</code></pre>
<ul>
<li><p>Extend the expression simplifier with more rules.</p></li>
<li><p>Add antiquotation to <code>quoteExprExp</code></p></li>
<li><p>Extend the expression quasiquoter to handle metavariables for numeric constants, allowing to implement simplification rules like</p></li>
</ul>
<pre><code>simpl [expr|$int:n$ + $int:m$|] = [expr| $int:m+n$ |]</code></pre>
<p>(you are welcome to invent your own syntax in place of <code>$int: ... $</code>)</p>
<ul>
<li>write a <code>matrix</code> quasiquoter such that</li>
</ul>
<pre><code>*MatrixSplice&gt; :{
*MatrixSplice| [matrix|
*MatrixSplice| 1 2
*MatrixSplice| 3 4
*MatrixSplice| |]
*MatrixSplice| :}
[[1,2],[3,4]]</code></pre>
<p>be careful with blank lines!</p>
</body>
</html>
