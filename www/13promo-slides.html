<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <meta name="date" content="2020-05-25" />
  <title>Advanced Functional Programming</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; } /* Alert */
code span.an { color: #008000; } /* Annotation */
code span.at { } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #0000ff; } /* ControlFlow */
code span.ch { color: #008080; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; } /* Comment */
code span.cv { color: #008000; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #0000ff; } /* Keyword */
code span.op { } /* Operator */
code span.ot { color: #ff4000; } /* Other */
code span.pp { color: #ff4000; } /* Preprocessor */
code span.sc { color: #008080; } /* SpecialChar */
code span.ss { color: #008080; } /* SpecialString */
code span.st { color: #008080; } /* String */
code span.va { } /* Variable */
code span.vs { color: #008080; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Advanced Functional Programming</h1>
  <p class="subtitle">Pleasure and Pain of Dependent Types in Haskell</p>
  <p class="author">
Marcin Benke
  </p>
  <p class="date">May 25, 2020</p>
</div>
<div class="slide section level1">

<meta name="duration" content="80" />
</div>
<div id="plan" class="slide section level1">
<h1>Plan</h1>
<p><a href="http://homepages.inf.ed.ac.uk/slindley/papers/hasochism.pdf">Hasochism - The Pleasure and Pain of Dependently Typed Haskell Programming</a></p>
<ol style="list-style-type: decimal">
<li><p>Kinds</p></li>
<li><p>GADT - <a href="https://en.wikibooks.org/wiki/Haskell/GADT">https://en.wikibooks.org/wiki/Haskell/GADT</a></p></li>
<li><p>Type promotion - <a href="https://github.com/slindley/dependent-haskel">https://github.com/slindley/dependent-haskell</a> <!--
``` {.haskell}
    data Nat = Z | S Nat
    data Vec :: Nat -> * -> * where
    vhead :: Vec (S n) a -> a
```
--></p></li>
<li><p>Type Families</p></li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">   <span class="kw">type</span> <span class="kw">family</span> (<span class="ot">m::</span><span class="dt">Nat</span>) <span class="op">:+</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">   vappend ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a</a>
<a class="sourceLine" id="cb1-3" title="3">   <span class="op">?</span><span class="ot"> ::</span> <span class="dt">Vec</span>(m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</a></code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Dynamic dependencies, singletons</li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">   <span class="kw">data</span> <span class="dt">Natty</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ot">   vchop ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</a>
<a class="sourceLine" id="cb2-3" title="3">   <span class="op">?</span><span class="ot"> ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a></code></pre></div>
</div>
<div id="plan-b" class="slide section level1">
<h1>Plan B</h1>
<ol start="6" style="list-style-type: decimal">
<li>Static dependencies, Proxy</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">   <span class="kw">data</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">NP</span> n</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ot">   vtake1 ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">NP</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a></code></pre></div>
<ol start="7" style="list-style-type: decimal">
<li>Kind polymorphism</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">   <span class="kw">data</span> <span class="dt">Proxy</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> i</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ot">   vtake2 ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a></code></pre></div>
<ol start="8" style="list-style-type: decimal">
<li>TypeApplication, getting rid of Proxy</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake4 two v</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ot">vtake4 ::</span> <span class="kw">forall</span> n m a<span class="op">.</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a></code></pre></div>
<ol start="9" style="list-style-type: decimal">
<li>Type equality and proofs</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> a <span class="op">:~:</span> b <span class="ot">=</span> (a <span class="op">~</span> b) <span class="ot">=&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">plus_id_r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> n <span class="op">:+</span> <span class="dt">Z</span> <span class="op">:~:</span> n</a></code></pre></div>
</div>
<div id="kinds" class="slide section level1">
<h1>Kinds</h1>
<ul>
<li><p>Operations on values are described by types</p></li>
<li><p>Operations on types are described by kinds</p></li>
<li><p>Types (e.g. <code>Int</code>) are of kind <code>*</code></p></li>
<li><p>One argument constructors (e.g. <code>Maybe</code>) are of kind <code>* -&gt; *</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">    pure ::</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="op">*</span>)<span class="op">.</span>a <span class="ot">-&gt;</span> f a</a></code></pre></div></li>
<li><p>There exist also more complex kinds, e.g. for monad transformers:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span> <span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">    lift ::</span> <span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">=&gt;</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="op">*</span>)<span class="op">.</span>m a <span class="ot">-&gt;</span> t m a</a></code></pre></div></li>
</ul>
<p>GHC has also an internal kind <code>#</code> for unboxed types (e.g. <code>Int#</code>)</p>
<p>As we shall see, more kinds may be introduced.</p>
</div>
<div id="expr1" class="slide section level1">
<h1>Expr1</h1>
<p>Consider a simple expression evaluator:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" title="2">          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-5" title="5">eval (<span class="dt">I</span> n)       <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb9-6" title="6">eval (<span class="dt">Add</span> e1 e2) <span class="ot">=</span> eval e1 <span class="op">+</span> eval e2</a></code></pre></div>
<p>What if we try to add <code>Bool</code>?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-2" title="2">          <span class="op">|</span> <span class="dt">B</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-3" title="3">          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb10-4" title="4">          <span class="op">|</span> <span class="dt">Eq</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></a></code></pre></div>
<p>What type should <code>eval</code> have?</p>
</div>
<div id="expr2" class="slide section level1">
<h1>Expr2</h1>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-2" title="2">          <span class="op">|</span> <span class="dt">B</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb11-3" title="3">          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb11-4" title="4">          <span class="op">|</span> <span class="dt">Eq</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="co">-- eval :: Either Int Bool ?</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co">-- eval (Add (B True) (I 1)) = ?</span></a>
<a class="sourceLine" id="cb11-8" title="8"></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb11-10" title="10">eval (<span class="dt">I</span> n)       <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Left</span> n)</a>
<a class="sourceLine" id="cb11-11" title="11">eval (<span class="dt">B</span> n)       <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Right</span> n)</a>
<a class="sourceLine" id="cb11-12" title="12">eval _ <span class="ot">=</span> <span class="fu">undefined</span>       <span class="co">-- Exercise</span></a></code></pre></div>
<p>How can we make typechecker reject <code>eval (Add (B True) (I 1))</code> ?</p>
</div>
<div id="expr3---phantom-types" class="slide section level1">
<h1>Expr3 - Phantom types</h1>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> a <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-2" title="2">            <span class="op">|</span> <span class="dt">B</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-3" title="3">            <span class="op">|</span> <span class="dt">Add</span> (<span class="dt">Expr</span> <span class="dt">Int</span>) (<span class="dt">Expr</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb12-4" title="4">            <span class="op">|</span> <span class="dt">Eq</span>  (<span class="dt">Expr</span> <span class="dt">Int</span>) (<span class="dt">Expr</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="ot">eval ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb12-8" title="8">eval (<span class="dt">I</span> n) <span class="ot">=</span> n <span class="co">-- Error: Couldn&#39;t match expected type ‘a’ with actual type ‘Int’</span></a></code></pre></div>
<p>besides <code>Add (B True) (I 1)</code> still typechecks.</p>
<p>The problem is that we have</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="dt">B</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a></code></pre></div>
<p>but want rather</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="dt">B</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></a></code></pre></div>
</div>
<div id="gadts---generalised-abstract-data-types" class="slide section level1">
<h1>GADTs - Generalised Abstract Data Types</h1>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="dt">B</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb15-7" title="7">  <span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-8" title="8">  <span class="dt">Eq</span><span class="ot">  ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb15-9" title="9">  <span class="co">-- exercise: allow comparing booleans, e.g `Eq (B True) (B True)`</span></a>
<a class="sourceLine" id="cb15-10" title="10"></a>
<a class="sourceLine" id="cb15-11" title="11"><span class="ot">eval ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb15-12" title="12">eval (<span class="dt">I</span> n)       <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb15-13" title="13">eval (<span class="dt">B</span> b)       <span class="ot">=</span> b</a>
<a class="sourceLine" id="cb15-14" title="14">eval (<span class="dt">Add</span> e1 e2) <span class="ot">=</span> eval e1 <span class="op">+</span> eval e2</a>
<a class="sourceLine" id="cb15-15" title="15">eval (<span class="dt">Eq</span>  e1 e2) <span class="ot">=</span> eval e1 <span class="op">==</span> eval e2</a>
<a class="sourceLine" id="cb15-16" title="16"></a>
<a class="sourceLine" id="cb15-17" title="17"><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Expr</span> a)</a></code></pre></div>
</div>
<div id="vec" class="slide section level1">
<h1>Vec</h1>
<p>Recall an example from the first lecture</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">data</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">data</span> <span class="dt">Succ</span> n</a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" title="5">  <span class="dt">VNil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a</a>
<a class="sourceLine" id="cb16-6" title="6"><span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a</a>
<a class="sourceLine" id="cb16-7" title="7"></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-9" title="9">vhead (x <span class="op">:&gt;</span> xs) <span class="ot">=</span> x</a></code></pre></div>
<p>Let us see how far we can go with dependent vectors in Haskell</p>
</div>
<div id="promotion" class="slide section level1">
<h1>Promotion</h1>
<p>If we have the <code>Nat</code> datatype, types for zero and successor can be automatically generated:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">{-# LANGUAGE GADTs, DataKinds, KindSignatures #-}</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">data</span> <span class="dt">Nat</span><span class="ot"> ::</span> <span class="op">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="dt">Z</span><span class="ot"> ::</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb17-4" title="4">  <span class="dt">S</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></a></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="co">-- This defines</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="co">-- Type Nat</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="co">-- Value constructors: Z, S</span></a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="co">-- Promotion (lifting) to type level yields</span></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="co">-- kind Nat</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="co">-- type constructors: &#39;Z :: Nat; &#39;S :: Nat -&gt; Nat</span></a>
<a class="sourceLine" id="cb18-8" title="8"><span class="co">-- &#39;s can be omitted in most cases, but...</span></a>
<a class="sourceLine" id="cb18-9" title="9"></a>
<a class="sourceLine" id="cb18-10" title="10"><span class="co">-- data P          -- 1</span></a>
<a class="sourceLine" id="cb18-11" title="11"><span class="co">-- data Prom = P   -- 2</span></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="co">-- type T = P      -- 1 or promoted 2?</span></a>
<a class="sourceLine" id="cb18-13" title="13"><span class="co">-- quote disambiguates:</span></a>
<a class="sourceLine" id="cb18-14" title="14"><span class="co">-- type T1 = P     -- 1</span></a>
<a class="sourceLine" id="cb18-15" title="15"><span class="co">-- type T2 = &#39;P    -- promoted 2</span></a></code></pre></div>
</div>
<div id="vec-with-promoted-nat" class="slide section level1">
<h1>Vec with promoted Nat</h1>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">data</span> <span class="dt">Nat</span><span class="ot"> ::</span> <span class="op">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="dt">Z</span><span class="ot"> ::</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="dt">S</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="co">-- Nat is a kind, and so is Nat -&gt; * -&gt; *</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="kw">infixr</span> <span class="dv">6</span> <span class="op">:&gt;</span></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-8" title="8">  <span class="dt">V0</span><span class="ot">   ::</span> <span class="dt">Vec</span> <span class="dt">&#39;Z</span> a</a>
<a class="sourceLine" id="cb19-9" title="9"><span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">&#39;S</span> n) a</a>
<a class="sourceLine" id="cb19-10" title="10"></a>
<a class="sourceLine" id="cb19-11" title="11"><span class="kw">deriving</span> <span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> n a)</a>
<a class="sourceLine" id="cb19-12" title="12"></a>
<a class="sourceLine" id="cb19-13" title="13"><span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb19-14" title="14">vhead (x<span class="op">:&gt;</span>_) <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb19-15" title="15"></a>
<a class="sourceLine" id="cb19-16" title="16"><span class="co">-- What should be the type of vtail?</span></a></code></pre></div>
</div>
<div id="other-promotion-examples" class="slide section level1">
<h1>Other promotion examples</h1>
<p>Heterogenous lists:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">data</span> <span class="dt">HList</span><span class="ot"> ::</span> [<span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="co">-- [*] is a list of types</span></a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="dt">HNil</span><span class="ot">  ::</span> <span class="dt">HList</span> &#39;[]</a>
<a class="sourceLine" id="cb20-3" title="3">  <span class="dt">HCons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HList</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> (a &#39;<span class="op">:</span> t)</a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="ot">foo0 ::</span> <span class="dt">HList</span> &#39;[]</a>
<a class="sourceLine" id="cb20-6" title="6">foo0 <span class="ot">=</span> <span class="dt">HNil</span></a>
<a class="sourceLine" id="cb20-7" title="7"></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="ot">foo1 ::</span> <span class="dt">HList</span> &#39;[<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb20-9" title="9">foo1 <span class="ot">=</span> <span class="dt">HCons</span> <span class="dv">3</span> <span class="dt">HNil</span></a>
<a class="sourceLine" id="cb20-10" title="10"></a>
<a class="sourceLine" id="cb20-11" title="11"><span class="ot">foo2 ::</span> <span class="dt">HList</span> [<span class="dt">Int</span>, <span class="dt">Bool</span>]</a>
<a class="sourceLine" id="cb20-12" title="12">foo2 <span class="ot">=</span> <span class="fu">undefined</span>  <span class="co">-- (easy) exercise</span></a></code></pre></div>
</div>
<div id="vector-concatenation" class="slide section level1">
<h1>Vector concatenation</h1>
<p>We have seen that addition can be defined with classes:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">class</span> <span class="dt">Add</span> (<span class="ot">a::</span><span class="dt">Nat</span>) (<span class="ot">b::</span><span class="dt">Nat</span>) (<span class="ot">c::</span><span class="dt">Nat</span>)  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">instance</span> <span class="dt">Add</span>  <span class="dt">Z</span>    b  b</a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">instance</span> <span class="dt">Add</span> a b c <span class="ot">=&gt;</span> <span class="dt">Add</span> (<span class="dt">S</span> a) b (<span class="dt">S</span> c)</a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="ot">vappend ::</span> (<span class="dt">Add</span> m n s) <span class="ot">=&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> s a</a>
<a class="sourceLine" id="cb21-7" title="7">vappend <span class="dt">V0</span> ys <span class="ot">=</span> ys</a></code></pre></div>
<p>alas…</p>
<pre><code>error: …
    • Could not deduce: n ~ s
      from the context: m ~ &#39;Z</code></pre>
<p>The constraint checker cannot infer <code>s = n</code> from <code>m = 0</code></p>
</div>
<div id="type-families" class="slide section level1">
<h1>Type families</h1>
<p>Type families provide more data for the constraint checker</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="op">:+</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Z</span> <span class="op">:+</span> m <span class="ot">=</span> m</a>
<a class="sourceLine" id="cb23-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">S</span> n) <span class="op">:+</span> m <span class="ot">=</span> <span class="dt">S</span> (n <span class="op">:+</span> m)</a>
<a class="sourceLine" id="cb23-4" title="4"></a>
<a class="sourceLine" id="cb23-5" title="5"><span class="ot">vapp ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a</a>
<a class="sourceLine" id="cb23-6" title="6">vapp <span class="dt">V0</span> ys <span class="ot">=</span> ys</a>
<a class="sourceLine" id="cb23-7" title="7">vapp (x<span class="op">:&gt;</span>xs) ys <span class="ot">=</span> x<span class="op">:&gt;</span>(vapp xs ys)</a></code></pre></div>
<p>Now <code>Z :+ m</code> can be reduced to <code>m</code> (at compile time)</p>
<p><strong>Exercise:</strong> define multiplication</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="op">:*</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></a></code></pre></div>
</div>
<div id="indexing" class="slide section level1">
<h1>Indexing</h1>
<p>You have probably seen some variant of <code>Fin</code> in Coq/Idris</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="co">-- atIndex :: Vec n a -&gt; (m &lt; n) -&gt; a</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">data</span> <span class="dt">Fin</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-4" title="4">    <span class="dt">FinZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)          <span class="co">-- zero is less than any successor</span></a>
<a class="sourceLine" id="cb25-5" title="5">    <span class="dt">FinS</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> n) <span class="co">-- n is less than (n+1)</span></a>
<a class="sourceLine" id="cb25-6" title="6"></a>
<a class="sourceLine" id="cb25-7" title="7"><span class="ot">atIndex ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-8" title="8">atIndex (x<span class="op">:&gt;</span>_) <span class="dt">FinZ</span> <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb25-9" title="9">atIndex (_<span class="op">:&gt;</span>xs) (<span class="dt">FinS</span> k) <span class="ot">=</span> atIndex xs k</a>
<a class="sourceLine" id="cb25-10" title="10"></a>
<a class="sourceLine" id="cb25-11" title="11"><span class="co">-- Exercise - why not:</span></a>
<a class="sourceLine" id="cb25-12" title="12"><span class="co">-- atIndex :: Vec (S n) a -&gt; ... ?</span></a></code></pre></div>
</div>
<div id="replicate" class="slide section level1">
<h1>Replicate</h1>
<p>Let’s try to define a vector counterpart of <code>replicate :: Int -&gt; a -&gt; [a]</code></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="ot">vreplicate ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</a>
<a class="sourceLine" id="cb26-2" title="2">vreplicate <span class="dt">Z</span> _ <span class="ot">=</span> <span class="dt">V0</span>   <span class="co">--  Expected type: Vec n a</span></a>
<a class="sourceLine" id="cb26-3" title="3">                      <span class="co">--  Actual type:   Vec &#39;Z a</span></a></code></pre></div>
<p>more precisely, we would like</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="ot">vreplicate2 ::</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</a></code></pre></div>
<p>…but <code>n::Nat</code> has no inhabitants</p>
<p><em>Exercise:</em> try your own ideas for <code>vreplicate</code></p>
<p>Before we implement <code>vreplicate</code> let us look at some other functions.</p>
</div>
<div id="vchop" class="slide section level1">
<h1>vchop</h1>
<p>We want to write a function dual to <code>vappend</code>, chopping a vector in two</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="op">--|</span> chop a vector <span class="kw">in</span> two</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="ot">vchop1 ::</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</a>
<a class="sourceLine" id="cb28-3" title="3">vchop1 _ _ <span class="ot">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p>Can we at least write a test for it?</p>
<pre><code>-- &gt;&gt;&gt; vchop1 (1 :&gt; 2 :&gt; V0)
-- ???</code></pre>
</div>
<div id="vchop2" class="slide section level1">
<h1>vchop2</h1>
<p>We need to count to <code>m</code>. Here’s an ugly solution:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="co">-- | Chop a vector in two, using first argument as a measure</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co">-- &gt;&gt;&gt; vchop2 (undefined :&gt; V0) (1 :&gt; 2 :&gt; V0)</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="co">-- (1 :&gt; V0,2 :&gt; V0)</span></a>
<a class="sourceLine" id="cb30-4" title="4"></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="co">-- NB if we had `vreplicate`, we might write</span></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="co">-- vchop2 (vreplicate (S Z) undefined) (1 :&gt; 2 :&gt; V0)</span></a>
<a class="sourceLine" id="cb30-7" title="7"></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="ot">vchop2 ::</span> <span class="dt">Vec</span> m x <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</a>
<a class="sourceLine" id="cb30-9" title="9">vchop2 <span class="dt">V0</span> xs <span class="ot">=</span> (<span class="dt">V0</span>, xs)</a>
<a class="sourceLine" id="cb30-10" title="10">vchop2 (_<span class="op">:&gt;</span>m) (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> (x<span class="op">:&gt;</span>ys, zs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-11" title="11">  (ys, zs) <span class="ot">=</span> vchop2 m xs</a></code></pre></div>
</div>
<div id="singleton" class="slide section level1">
<h1>Singleton</h1>
<p>Usin a vector is an overkill, we need just its length.</p>
<p>But <code>Nat</code> is not precise enough; it’s like <code>[a]</code> - no size checking.</p>
<p>Idea: create a representant of every element of kind Nat</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="co">-- SNat n ~~ Vec n ()</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="kw">data</span> <span class="dt">SNat</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-3" title="3">  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb31-4" title="4">  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb31-5" title="5"><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span>(<span class="dt">SNat</span> n)</a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="ot">add ::</span> (<span class="dt">SNat</span> m) <span class="ot">-&gt;</span> (<span class="dt">SNat</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span>(m <span class="op">:+</span> n)</a>
<a class="sourceLine" id="cb31-8" title="8">add <span class="dt">SZ</span> n <span class="ot">=</span> n</a>
<a class="sourceLine" id="cb31-9" title="9">add (<span class="dt">SS</span> m) n <span class="ot">=</span> <span class="dt">SS</span> (add m n)</a></code></pre></div>
<p><strong>Exercise:</strong> define multiplication</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="ot">mul ::</span> (<span class="dt">SNat</span> m) <span class="ot">-&gt;</span> (<span class="dt">SNat</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span>(m <span class="op">:*</span> n)</a></code></pre></div>
</div>
<div id="comparisons-and-another-way-of-vector-indexing" class="slide section level1">
<h1>Comparisons and another way of vector indexing</h1>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="co">-- # Comparison</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">m::</span><span class="dt">Nat</span>) <span class="op">:&lt;</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> m <span class="op">:&lt;</span> <span class="dt">&#39;Z</span> <span class="ot">=</span> <span class="dt">&#39;False</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">&#39;Z</span> <span class="op">:&lt;</span> (<span class="dt">&#39;S</span> n) <span class="ot">=</span> <span class="dt">&#39;True</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">&#39;S</span> m) <span class="op">:&lt;</span> (<span class="dt">&#39;S</span> n) <span class="ot">=</span> m <span class="op">:&lt;</span> n</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="co">-- nth</span></a>
<a class="sourceLine" id="cb33-8" title="8"><span class="ot">nth ::</span> (m<span class="op">:&lt;</span>n) <span class="op">~</span> <span class="dt">&#39;True</span> <span class="ot">=&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb33-9" title="9">nth <span class="dt">SZ</span> (a<span class="op">:&gt;</span>_)  <span class="ot">=</span> a</a>
<a class="sourceLine" id="cb33-10" title="10">nth (<span class="dt">SS</span> m&#39;) (_<span class="op">:&gt;</span>xs) <span class="ot">=</span> nth m&#39; xs</a></code></pre></div>
<p>Apart from ordinary class constraints, we may use equality constraints.</p>
<p><code>(m:&lt;n) ~ 'True</code> is ane example of such a constraint</p>
<p><code>nth</code> typechecks without this constraint, but so does <code>nth SZ V0</code> which is unsafe.</p>
<p>With the constraint, we get:</p>
<pre><code>&gt; nth SZ V0
    • Couldn&#39;t match type ‘&#39;False’ with ‘&#39;True’
        arising from a use of ‘nth’
    • In the expression: nth SZ V0</code></pre>
</div>
<div id="vchop3" class="slide section level1">
<h1>vchop3</h1>
<p>With <code>SNat</code> we can implement <code>vchop</code> properly:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="co">-- | chop a vector in two parts</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="co">-- &gt;&gt;&gt; vchop (SS SZ) (Vcons 1 (Vcons 2 V0))</span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="co">-- (Vcons 1 V0,Vcons 2 V0)</span></a>
<a class="sourceLine" id="cb35-4" title="4">vchop <span class="ot">=</span> vchop3</a>
<a class="sourceLine" id="cb35-5" title="5"><span class="ot">vchop3 ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span>(m<span class="op">:+</span>n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</a>
<a class="sourceLine" id="cb35-6" title="6">vchop3 <span class="dt">SZ</span> xs <span class="ot">=</span> (<span class="dt">V0</span>, xs)</a>
<a class="sourceLine" id="cb35-7" title="7">vchop3 (<span class="dt">SS</span> m) (<span class="dt">Vcons</span> x xs) <span class="ot">=</span> (<span class="dt">Vcons</span> x ys, zs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-8" title="8">  (ys,zs) <span class="ot">=</span> vchop3 m xs</a></code></pre></div>
</div>
<div id="vreplicate" class="slide section level1">
<h1>vreplicate</h1>
<p>Also <code>vreplicate</code> becomes easy:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="co">-- | `vreplicate n a` is a vector of n copies of a</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">-- &gt;&gt;&gt; vreplicate (SS SZ) 1</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">-- 1 :&gt; V0</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">-- &gt;&gt;&gt; vreplicate (SS (SS SZ)) 1</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="ot">vreplicate ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</a>
<a class="sourceLine" id="cb36-7" title="7">vreplicate <span class="dt">SZ</span> _ <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb36-8" title="8">vreplicate (<span class="dt">SS</span> n) x <span class="ot">=</span> x <span class="op">:&gt;</span> (vreplicate n x)</a></code></pre></div>
<p><strong>Exercise:</strong> define</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="ot">vcycle ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (n<span class="op">:*</span>m) a</a></code></pre></div>
</div>
<div id="vtake" class="slide section level1">
<h1>vtake</h1>
<p>We want to define a vector counterpart of <code>take</code></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></a>
<a class="sourceLine" id="cb38-2" title="2"></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="ot">vtake1 ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) <span class="ot">-&gt;</span> <span class="dt">Vec</span> m x</a>
<a class="sourceLine" id="cb38-4" title="4">vtake1  <span class="dt">SZ</span>     xs     <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb38-5" title="5">vtake1 (<span class="dt">SS</span> m) (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake1 m xs</a></code></pre></div>
<pre class="error"><code>error: …
    • Could not deduce: (n1 :+ n0) ~ n2
      from the context: m ~ &#39;S n1
      Expected type: Vec (n1 :+ n0) a
        Actual type: Vec n2 a
      In the second argument of ‘vtake1’, namely ‘xs’
      In the second argument of ‘(:&gt;)’, namely ‘vtake1 m xs’
    • Relevant bindings include
        xs :: Vec n2 a
        m :: SNat n1</code></pre>
<p>The compiler cannot type the recursive case.</p>
<p>NB <code>AllowAmbiguousTypes</code> is needed if we want the compiler to even try to typecheck this.</p>
</div>
<div id="injectivity" class="slide section level1">
<h1>Injectivity</h1>
<pre><code>    • Could not deduce: (n1 :+ n0) ~ n2
      from the context: m ~ &#39;S n1</code></pre>
<p>The problem is whether <code>(m :+)</code> is injective.</p>
<p><code>Maybe a ~ Maybe b =&gt; a ~ b</code></p>
<p>but it’s harder to see, if</p>
<p><code>m :+ n0 ~ m :+ n1 =&gt; n0 ~ n1</code></p>
<p>More precisely in the type</p>
<p><code>vtake1 :: SNat m -&gt; Vec (m :+ n) -&gt; Vec m x</code></p>
<p>we lack a “handle” on <code>n</code>; with real dependent types we would write</p>
<pre><code>(m : Nat) -&gt; (n : Nat) -&gt; Vec (m + n) x -&gt; Vec m x</code></pre>
</div>
<div id="using-a-concrete-handle" class="slide section level1">
<h1>Using a concrete handle</h1>
<p>we lack a “handle” on <code>n</code>; with real dependent types we would write</p>
<pre><code>(m : Nat) -&gt; (n : Nat) -&gt; Vec (m + n) x -&gt; Vec m x</code></pre>
<p>So let us try translating this using singletons:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="ot">vtake1&#39; ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a>
<a class="sourceLine" id="cb43-2" title="2">vtake1&#39; <span class="dt">SZ</span> _  _ <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb43-3" title="3">vtake1&#39; (<span class="dt">SS</span> m) n (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake1&#39; m n xs</a></code></pre></div>
<p>This works, but we need to pass an additional parameter — the length <code>n</code> of the vector remainder:</p>
<pre><code>let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake1&#39; two (SS SZ) v
1 :&gt; (1 :&gt; V0)</code></pre>
<p>But we do not need he value of <code>n</code>, only its type.</p>
</div>
<div id="proxy---an-abstract-handle" class="slide section level1">
<h1><code>Proxy</code> - an abstract handle</h1>
<p>Let us try to build an abstract handle:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="co">-- | Nat Proxy</span></a>
<a class="sourceLine" id="cb45-2" title="2"><span class="kw">data</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">NP</span> n</a>
<a class="sourceLine" id="cb45-3" title="3"></a>
<a class="sourceLine" id="cb45-4" title="4"><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake2 two NP v</span></a>
<a class="sourceLine" id="cb45-5" title="5"><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></a>
<a class="sourceLine" id="cb45-6" title="6"><span class="ot">vtake2 ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">NP</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a>
<a class="sourceLine" id="cb45-7" title="7">vtake2 <span class="dt">SZ</span>     _ _ <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb45-8" title="8">vtake2 (<span class="dt">SS</span> m) n (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake2 m n xs</a></code></pre></div>
<p>Note: this is different from a singleton.</p>
</div>
<div id="a-universal-handle" class="slide section level1">
<h1>A universal handle</h1>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="co">-- | Nat Proxy</span></a>
<a class="sourceLine" id="cb46-2" title="2"><span class="kw">data</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">NP</span> n</a></code></pre></div>
<p>there is no reason why our handle should depend on <code>Nat</code>, so why not make it polymorphic?</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="ot">{-# LANGUAGE PolyKinds #-}</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="co">-- | Generic Proxy</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="kw">data</span> <span class="dt">Proxy</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-4" title="4">  <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="ot">i::</span>k)</a>
<a class="sourceLine" id="cb47-5" title="5"></a>
<a class="sourceLine" id="cb47-6" title="6"><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake3 two Proxy v</span></a>
<a class="sourceLine" id="cb47-7" title="7"><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></a>
<a class="sourceLine" id="cb47-8" title="8"><span class="ot">vtake3 ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a>
<a class="sourceLine" id="cb47-9" title="9">vtake3 <span class="dt">SZ</span>     _ _ <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb47-10" title="10">vtake3 (<span class="dt">SS</span> m) n (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake3 m n xs</a></code></pre></div>
<p><strong>Uwaga:</strong> <code>k</code> is a kind variable, hence the need for <code>PolyKinds</code></p>
</div>
<div id="back-to-the-future-or-another-take-on-vtake1" class="slide section level1">
<h1>Back to the future or another take on vtake1</h1>
<p>Since 8.0 GHC allows explicit type applications, e.g.</p>
<pre><code>Prelude&gt; :set -XTypeApplications
Prelude&gt; :t read
read :: Read a =&gt; String -&gt; a
Prelude&gt; read @Int &quot;42&quot;
42
Prelude&gt; read @Double &quot;42&quot;
42.0</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="co">-- vtake4 requires:</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="co">-- {-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="co">-- {-# LANGUAGE TypeApplications #-}</span></a>
<a class="sourceLine" id="cb49-4" title="4"></a>
<a class="sourceLine" id="cb49-5" title="5"><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake4 two v</span></a>
<a class="sourceLine" id="cb49-6" title="6"><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></a>
<a class="sourceLine" id="cb49-7" title="7"><span class="ot">vtake4 ::</span> <span class="kw">forall</span> n m a<span class="op">.</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</a>
<a class="sourceLine" id="cb49-8" title="8">vtake4 <span class="dt">SZ</span> _ <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb49-9" title="9">vtake4 (<span class="dt">SS</span> m) (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake4 <span class="op">@</span>n m xs</a></code></pre></div>
</div>
<div id="reversing-vec" class="slide section level1">
<h1>Reversing Vec</h1>
<p>Let’s try a naive vector reverse:</p>
<pre><code>rev1 :: Vec n a -&gt; Vec n a
vrev1 V0 = V0
vrev1 (x:&gt;xs) = vapp (vrev1 xs) (x:&gt;V0)</code></pre>
<p>As you might suspect, this does not work:</p>
<pre><code>    • Could not deduce: (n1 :+ &#39;S &#39;Z) ~ &#39;S n1
      from the context: n ~ &#39;S n1</code></pre>
<p>Oh noes, we need to prove <code>n + 1 ~ S n</code></p>
</div>
<div id="vrev2" class="slide section level1">
<h1>vrev2</h1>
<p>We may work around this using a speccialized “append one” function:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" title="1"><span class="co">-- | vrev2</span></a>
<a class="sourceLine" id="cb52-2" title="2"><span class="co">-- &gt;&gt;&gt; vrev2 (1:&gt;2:&gt;3:&gt;V0)</span></a>
<a class="sourceLine" id="cb52-3" title="3"><span class="co">-- 3 :&gt; (2 :&gt; (1 :&gt; V0))</span></a>
<a class="sourceLine" id="cb52-4" title="4"><span class="ot">vrev2 ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</a>
<a class="sourceLine" id="cb52-5" title="5">vrev2 <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb52-6" title="6">vrev2 (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> vappOne (vrev2 xs) x</a>
<a class="sourceLine" id="cb52-7" title="7"></a>
<a class="sourceLine" id="cb52-8" title="8"><span class="ot">vappOne ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">S</span> n) a</a>
<a class="sourceLine" id="cb52-9" title="9">vappOne <span class="dt">V0</span> y <span class="ot">=</span> y <span class="op">:&gt;</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb52-10" title="10">vappOne (x<span class="op">:&gt;</span>xs) y <span class="ot">=</span> x <span class="op">:&gt;</span> vappOne xs y</a></code></pre></div>
<p>but we would prefer to use append we have already written.</p>
</div>
<div id="better-reverse-with-an-accumulator" class="slide section level1">
<h1>Better reverse with an accumulator</h1>
<pre><code>vrev3 :: Vec n a -&gt; Vec n a
vrev3 xs = vaccrev V0 xs

vaccrev :: Vec n a -&gt; Vec m a -&gt; Vec (n :+ m) a
vaccrev acc V0 = acc</code></pre>
<p>Oh noes, now we fail even in the base case:</p>
<pre><code>    • Could not deduce: (n :+ &#39;Z) ~ n</code></pre>
<p>Now we need to prove <code>n + 0 ~ n</code> too.</p>
</div>
<div id="type-equality-and-proofs" class="slide section level1">
<h1>Type Equality and proofs</h1>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" title="1"><span class="co">-- cf Data.Type.Equality</span></a>
<a class="sourceLine" id="cb55-2" title="2"></a>
<a class="sourceLine" id="cb55-3" title="3">infix <span class="dv">4</span> <span class="op">:~:</span></a>
<a class="sourceLine" id="cb55-4" title="4"></a>
<a class="sourceLine" id="cb55-5" title="5"><span class="kw">data</span> a <span class="op">:~:</span> b <span class="kw">where</span></a>
<a class="sourceLine" id="cb55-6" title="6">  <span class="dt">Refl</span><span class="ot"> ::</span>  a <span class="op">:~:</span> a</a>
<a class="sourceLine" id="cb55-7" title="7"><span class="co">-- data a :~: b = (a ~ b) =&gt; Refl</span></a>
<a class="sourceLine" id="cb55-8" title="8"></a>
<a class="sourceLine" id="cb55-9" title="9"><span class="ot">sym ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (b <span class="op">:~:</span> a)</a>
<a class="sourceLine" id="cb55-10" title="10">sym <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span>  <span class="co">-- seems trivial, but see if you can simplify it...</span></a>
<a class="sourceLine" id="cb55-11" title="11"></a>
<a class="sourceLine" id="cb55-12" title="12"><span class="ot">trans ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (b <span class="op">:~:</span> c) <span class="ot">-&gt;</span> (a <span class="op">:~:</span> c)</a>
<a class="sourceLine" id="cb55-13" title="13">trans <span class="dt">Refl</span> <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb55-14" title="14"></a>
<a class="sourceLine" id="cb55-15" title="15"><span class="ot">cong ::</span> <span class="kw">forall</span> f a b<span class="op">.</span>a <span class="op">:~:</span> b <span class="ot">-&gt;</span> f a <span class="op">:~:</span> f b</a>
<a class="sourceLine" id="cb55-16" title="16">cong <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb55-17" title="17"></a>
<a class="sourceLine" id="cb55-18" title="18"><span class="co">-- (a ~ b) implies (f a) implies (f b)</span></a>
<a class="sourceLine" id="cb55-19" title="19"><span class="ot">subst ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb55-20" title="20">subst <span class="dt">Refl</span> <span class="ot">=</span> <span class="fu">id</span></a></code></pre></div>
</div>
<div id="some-proofs" class="slide section level1">
<h1>Some proofs</h1>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1"><span class="co">-- Trivial lemma: 0+n ~ n; explicit quantification</span></a>
<a class="sourceLine" id="cb56-2" title="2"><span class="ot">plus_id_l ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Z</span> <span class="op">:+</span> n <span class="op">:~:</span> n</a>
<a class="sourceLine" id="cb56-3" title="3">plus_id_l _ <span class="ot">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb56-4" title="4"></a>
<a class="sourceLine" id="cb56-5" title="5"><span class="co">-- implicit quantification</span></a>
<a class="sourceLine" id="cb56-6" title="6"><span class="ot">plus_id_l_impl ::</span> n <span class="op">:~:</span> <span class="dt">Z</span> <span class="op">:+</span> n</a>
<a class="sourceLine" id="cb56-7" title="7">plus_id_l_impl <span class="ot">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb56-8" title="8"></a>
<a class="sourceLine" id="cb56-9" title="9"><span class="co">-- Prove by induction: n+0 ~ n</span></a>
<a class="sourceLine" id="cb56-10" title="10"><span class="co">-- Pattern-match on n, so explicit quantification</span></a>
<a class="sourceLine" id="cb56-11" title="11"><span class="co">-- Compare with Coq Agda or Idris</span></a>
<a class="sourceLine" id="cb56-12" title="12"><span class="ot">plus_id_r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> n <span class="op">:+</span> <span class="dt">Z</span> <span class="op">:~:</span> n</a>
<a class="sourceLine" id="cb56-13" title="13">plus_id_r <span class="dt">SZ</span> <span class="ot">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb56-14" title="14">plus_id_r (<span class="dt">SS</span> m) <span class="ot">=</span> cong <span class="op">@</span><span class="dt">S</span> (plus_id_r m)</a>
<a class="sourceLine" id="cb56-15" title="15"><span class="co">-- @S is optional above, added only for clarity</span></a></code></pre></div>
</div>
<div id="provably-safe-casts" class="slide section level1">
<h1>Provably safe casts</h1>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" title="1"><span class="co">-- | Typesafe cast using propositional equality</span></a>
<a class="sourceLine" id="cb57-2" title="2"><span class="co">-- simple but not very useful (subst is more powerful)</span></a>
<a class="sourceLine" id="cb57-3" title="3"><span class="ot">castWith ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb57-4" title="4">castWith <span class="dt">Refl</span> x <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb57-5" title="5"></a>
<a class="sourceLine" id="cb57-6" title="6"><span class="co">-- | Generalised form of typesafe cast</span></a>
<a class="sourceLine" id="cb57-7" title="7"><span class="ot">gcastWith ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (a <span class="op">~</span> b <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb57-8" title="8">gcastWith <span class="dt">Refl</span> x <span class="ot">=</span> x</a>
<a class="sourceLine" id="cb57-9" title="9"></a>
<a class="sourceLine" id="cb57-10" title="10"><span class="ot">simpl0r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> f (n<span class="op">:+</span><span class="dt">Z</span>) <span class="ot">-&gt;</span> f n</a>
<a class="sourceLine" id="cb57-11" title="11"><span class="co">-- Special case: Vec (n:+Z) a -&gt; Vec n a</span></a>
<a class="sourceLine" id="cb57-12" title="12">simpl0r n v <span class="ot">=</span> castWith (cong (plus_id_r n)) v</a>
<a class="sourceLine" id="cb57-13" title="13"><span class="co">-- simpl0r n v = subst (plus_id_r n) v</span></a>
<a class="sourceLine" id="cb57-14" title="14"></a>
<a class="sourceLine" id="cb57-15" title="15"><span class="ot">expand0r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> f n <span class="ot">-&gt;</span> f(n<span class="op">:+</span><span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb57-16" title="16">expand0r n x <span class="ot">=</span> subst (sym (plus_id_r n)) x</a>
<a class="sourceLine" id="cb57-17" title="17"></a>
<a class="sourceLine" id="cb57-18" title="18"><span class="co">-- Instead of `subst ... sym` we can put the constraint solver to work</span></a>
<a class="sourceLine" id="cb57-19" title="19"><span class="co">-- you can think of it as a kind of tactic</span></a>
<a class="sourceLine" id="cb57-20" title="20"><span class="ot">expand0r&#39; ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> f n <span class="ot">-&gt;</span> f(n<span class="op">:+</span><span class="dt">Z</span>)</a>
<a class="sourceLine" id="cb57-21" title="21">expand0r&#39; n x <span class="ot">=</span> gcastWith (plus_id_r n) x</a></code></pre></div>
</div>
<div id="one-more-lemma" class="slide section level1">
<h1>One more lemma</h1>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" title="1"><span class="co">-- n + S m ~ S(m+n)</span></a>
<a class="sourceLine" id="cb58-2" title="2"><span class="co">-- implicit m, explicit n</span></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="ot">plus_succ_r ::</span> <span class="kw">forall</span> m n<span class="op">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> n <span class="op">:+</span> <span class="dt">S</span> m <span class="op">:~:</span> <span class="dt">S</span>(n <span class="op">:+</span> m)</a>
<a class="sourceLine" id="cb58-4" title="4">plus_succ_r <span class="dt">SZ</span> <span class="ot">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb58-5" title="5">plus_succ_r (<span class="dt">SS</span> n1) <span class="ot">=</span> cong <span class="op">@</span><span class="dt">S</span> (plus_succ_r <span class="op">@</span>m n1)</a>
<a class="sourceLine" id="cb58-6" title="6"></a>
<a class="sourceLine" id="cb58-7" title="7"><span class="co">-- explicit m, n</span></a>
<a class="sourceLine" id="cb58-8" title="8"><span class="ot">plus_succ_r2 ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> n <span class="op">:+</span> <span class="dt">S</span> m <span class="op">:~:</span> <span class="dt">S</span>(n <span class="op">:+</span> m)</a>
<a class="sourceLine" id="cb58-9" title="9">plus_succ_r2 <span class="dt">SZ</span> m <span class="ot">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb58-10" title="10">plus_succ_r2 (<span class="dt">SS</span> n1) m <span class="ot">=</span> cong <span class="op">@</span><span class="dt">S</span> (plus_succ_r2 n1 m)</a></code></pre></div>
</div>
<div id="type-safe-reverse" class="slide section level1">
<h1>Type-safe reverse</h1>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" title="1"><span class="ot">rev ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb59-2" title="2">rev [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb59-3" title="3">rev xs <span class="ot">=</span> go [] xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-4" title="4">  go acc [] <span class="ot">=</span> acc</a>
<a class="sourceLine" id="cb59-5" title="5">  go acc (h<span class="op">:</span>t) <span class="ot">=</span> go (h<span class="op">:</span>acc) t</a>
<a class="sourceLine" id="cb59-6" title="6"></a>
<a class="sourceLine" id="cb59-7" title="7"><span class="ot">accrev ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n</a>
<a class="sourceLine" id="cb59-8" title="8">accrev <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb59-9" title="9">accrev xs <span class="ot">=</span> go <span class="dt">SZ</span> <span class="dt">V0</span> xs <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-10" title="10"><span class="ot">  go ::</span> <span class="kw">forall</span> m n a<span class="op">.</span><span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (n<span class="op">:+</span>m)</a>
<a class="sourceLine" id="cb59-11" title="11">  go alen acc <span class="dt">V0</span> <span class="ot">=</span> expand0r alen acc</a>
<a class="sourceLine" id="cb59-12" title="12">  go alen acc (h<span class="op">:&gt;</span>t) <span class="ot">=</span> gcastWith (plus_succ_r2 alen (size t))</a>
<a class="sourceLine" id="cb59-13" title="13">                     <span class="op">$</span> go (<span class="dt">SS</span> alen) (h<span class="op">:&gt;</span>acc) t</a>
<a class="sourceLine" id="cb59-14" title="14"></a>
<a class="sourceLine" id="cb59-15" title="15">main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> accrev <span class="op">$</span> <span class="dv">1</span> <span class="op">:&gt;</span> <span class="dv">2</span> <span class="op">:&gt;</span> <span class="dv">3</span> <span class="op">:&gt;</span> <span class="dt">V0</span></a>
<a class="sourceLine" id="cb59-16" title="16"></a>
<a class="sourceLine" id="cb59-17" title="17"><span class="ot">size ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">SNat</span> n</a>
<a class="sourceLine" id="cb59-18" title="18">size <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">SZ</span></a>
<a class="sourceLine" id="cb59-19" title="19">size (_<span class="op">:&gt;</span>t) <span class="ot">=</span> <span class="dt">SS</span> (size t)</a></code></pre></div>
</div>
<div id="exercises" class="slide section level1">
<h1>Exercises</h1>
<p>Exercise: implement a vector variant of</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" title="1"><span class="ot">naiverev ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb60-2" title="2">naiverev [] <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb60-3" title="3">naiverev (x<span class="op">:</span>xs) <span class="ot">=</span> naiverev xs <span class="op">++</span> [x]</a></code></pre></div>
<p>Challenge: try to eliminate <code>size</code> from <code>accrev</code> by using proxies or type app (there is <code>Data.Vect</code>, stackoverflow and blogs but try to roll your own before you peek at other solutions).</p>
</div>
<div id="questions" class="slide section level1">
<h1>Questions?</h1>
</div>
<div id="type-level-literals" class="slide section level1">
<h1>Type level literals</h1>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" title="1"><span class="ot">{-# LANGUAGE KindSignatures, DataKinds #-}</span></a>
<a class="sourceLine" id="cb61-2" title="2"></a>
<a class="sourceLine" id="cb61-3" title="3"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> (<span class="dt">Symbol</span>) <span class="co">-- strings promoted to types</span></a>
<a class="sourceLine" id="cb61-4" title="4"><span class="kw">import</span> <span class="dt">Data.Ratio</span> ((%))</a>
<a class="sourceLine" id="cb61-5" title="5"></a>
<a class="sourceLine" id="cb61-6" title="6"><span class="kw">newtype</span> <span class="dt">Money</span> (<span class="ot">currency ::</span> <span class="dt">Symbol</span>) <span class="ot">=</span> <span class="dt">Money</span> <span class="dt">Rational</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb61-7" title="7"></a>
<a class="sourceLine" id="cb61-8" title="8"><span class="ot">fivePence ::</span> <span class="dt">Money</span> <span class="st">&quot;GBP&quot;</span></a>
<a class="sourceLine" id="cb61-9" title="9">fivePence <span class="ot">=</span> <span class="dt">Money</span> (<span class="dv">5</span> <span class="op">%</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb61-10" title="10"></a>
<a class="sourceLine" id="cb61-11" title="11"><span class="ot">twoEuros ::</span> <span class="dt">Money</span> <span class="st">&quot;EUR&quot;</span></a>
<a class="sourceLine" id="cb61-12" title="12">twoEuros <span class="ot">=</span> <span class="dt">Money</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb61-13" title="13"></a>
<a class="sourceLine" id="cb61-14" title="14"><span class="ot">add ::</span> <span class="dt">Money</span> c <span class="ot">-&gt;</span> <span class="dt">Money</span> c <span class="ot">-&gt;</span> <span class="dt">Money</span> c</a>
<a class="sourceLine" id="cb61-15" title="15">add (<span class="dt">Money</span> x) (<span class="dt">Money</span> y) <span class="ot">=</span> <span class="dt">Money</span> (x <span class="op">+</span> y)</a>
<a class="sourceLine" id="cb61-16" title="16"></a>
<a class="sourceLine" id="cb61-17" title="17"><span class="co">-- &gt;&gt;&gt; add fivePence fivePence</span></a>
<a class="sourceLine" id="cb61-18" title="18"><span class="co">-- Money (1 % 10)</span></a>
<a class="sourceLine" id="cb61-19" title="19"></a>
<a class="sourceLine" id="cb61-20" title="20"><span class="co">-- &gt;&gt;&gt; add fivePence twoEuros</span></a>
<a class="sourceLine" id="cb61-21" title="21"><span class="co">-- &lt;interactive&gt;:18:15: error:</span></a>
<a class="sourceLine" id="cb61-22" title="22"><span class="co">--    • Couldn&#39;t match type ‘&quot;EUR&quot;’ with ‘&quot;GBP&quot;’</span></a>
<a class="sourceLine" id="cb61-23" title="23"><span class="co">--      Expected type: Money &quot;GBP&quot;</span></a>
<a class="sourceLine" id="cb61-24" title="24"><span class="co">--        Actual type: Money &quot;EUR&quot;</span></a></code></pre></div>
</div>
<div id="type-level-numbers-kind-level-tuples" class="slide section level1">
<h1>Type level numbers, kind level tuples</h1>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" title="1"><span class="ot">{-# LANGUAGE KindSignatures, DataKinds #-}</span></a>
<a class="sourceLine" id="cb62-2" title="2"></a>
<a class="sourceLine" id="cb62-3" title="3"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> (<span class="dt">Symbol</span>, <span class="dt">Nat</span>)</a>
<a class="sourceLine" id="cb62-4" title="4"></a>
<a class="sourceLine" id="cb62-5" title="5"><span class="kw">newtype</span> <span class="dt">Discrete</span> (<span class="ot">currency ::</span> <span class="dt">Symbol</span>) (<span class="ot">scale ::</span> (<span class="dt">Nat</span>, <span class="dt">Nat</span>))</a>
<a class="sourceLine" id="cb62-6" title="6">  <span class="ot">=</span> <span class="dt">Discrete</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb62-7" title="7"></a>
<a class="sourceLine" id="cb62-8" title="8"><span class="ot">oneDollar ::</span> <span class="dt">Discrete</span> <span class="st">&quot;USD&quot;</span> &#39;(<span class="dv">1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb62-9" title="9">oneDollar <span class="ot">=</span> <span class="dt">Discrete</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb62-10" title="10"></a>
<a class="sourceLine" id="cb62-11" title="11"><span class="ot">oneDollarThirtyCents ::</span> <span class="dt">Discrete</span> <span class="st">&quot;USD&quot;</span> &#39;(<span class="dv">100</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb62-12" title="12">oneDollarThirtyCents <span class="ot">=</span> <span class="dt">Discrete</span> <span class="dv">130</span></a></code></pre></div>
<p>In <code>scale :: (Nat, Nat)</code>, <code>(,)</code> is the tuple type promoted to a kind via DataKinds.</p>
<p>In <code>'(100, 1), '(,)</code> is the tuple data constructor promoted to a type constructor.</p>
</div>
</body>
</html>
